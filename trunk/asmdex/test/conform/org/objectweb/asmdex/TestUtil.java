/* Software Name : AsmDex
 * Version : 1.0
 *
 * Copyright © 2012 France Télécom
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the copyright holders nor the names of its
 *    contributors may be used to endorse or promote products derived from
 *    this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */
package org.objectweb.asmdex;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertTrue;

import java.io.BufferedReader;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.Reader;
import java.io.StringWriter;
import java.io.Writer;
import java.lang.reflect.Method;
import java.net.URL;
import java.net.URLClassLoader;
import java.util.Arrays;

/**
 * Utility class for Test.
 * 
 * The temporary folder/files management is sadly useful, because Baksmali is bugged and can't use
 * the temporary folder given by JUnit (Baksmali can't reach the root folder), so we have to manage
 * them by ourselves.
 * 
 * @author Julien Névo
 */
public class TestUtil {

	/** The path folder. */
	public static final String PATH_FOLDER_TEST = "test/";
	/**
	 * conform
	 */
	public static final String PATH_FOLDER_CONFORM = "conform/";
	/**
	 * test case folder
	 */
	public static final String PATH_FOLDER_TESTCASE = PATH_FOLDER_TEST + "case/";
	
	// Name of the file generated by AsmDexifier for the tests.
	/**
	 * Name of file generated without extension
	 */
	public static final String FILENAME_TESTDUMP_NO_EXTENSION = "TestDump";
	/**
	 * Name of file generated with extension
	 */
	public static final String FILENAME_TESTDUMP = FILENAME_TESTDUMP_NO_EXTENSION + ".java";
	
	// Subfolders to the dex test case files, according to what tests has to be performed.
	/**
	 * full test subfolder
	 */
	public static final String FULL_TEST_SUBFOLDER = "full/";
	/**
	 * folder for skiping line numbers
	 */
	public static final String SKIP_LINE_NUMBERS_TEST_SUBFOLDER = "skipLineNumbers/";

	/**
	 * filename helloworld dex
	 */
	public static final String FILENAME_HELLO_WORLD_DEX = "helloWorld.dex";
	/**
	 * filename annotationTest dex
	 */
	public static final String FILENAME_ANNOTATION_TESTS_DEX = "annotationTests.dex";
	/**
	 * filename api demos
	 */
	public static final String FILENAME_API_DEMOS_DEX = "apiDemos.dex";
	/**
	 * path to test demo dex
	 */
	public static final String FILENAME_EXCEPTION_TESTS_DEMOS_DEX = "exceptionTests.dex";
	/**
	 * path to hello world test
	 */
	public static final String PATH_AND_FILENAME_HELLO_WORLD_DEX = PATH_FOLDER_TESTCASE + FULL_TEST_SUBFOLDER + FILENAME_HELLO_WORLD_DEX;
	/**
	 * path to annotation tests dex
	 */
	public static final String PATH_AND_FILENAME_ANNOTATION_TESTS_DEX = PATH_FOLDER_TESTCASE + FULL_TEST_SUBFOLDER + FILENAME_ANNOTATION_TESTS_DEX;
	/**
	 * path to api demos dex
	 */
	public static final String PATH_AND_FILENAME_API_DEMOS_DEX = PATH_FOLDER_TESTCASE + SKIP_LINE_NUMBERS_TEST_SUBFOLDER + FILENAME_API_DEMOS_DEX;
	/**
	 * path to exception tests
	 */
	public static final String PATH_AND_FILENAME_EXCEPTION_TESTS_DEX = PATH_FOLDER_TESTCASE + FULL_TEST_SUBFOLDER + FILENAME_EXCEPTION_TESTS_DEMOS_DEX;
	
	/**
	 * Generated dex filename
	 */
	public static final String FILENAME_GENERATED_DEX = "generated.dex";
	
	// Generated original file from which the Adapters are working.
	/**
	 * Original dex filename
	 */
	public static final String FILENAME_ORIGINAL_DEX = "original.dex";
	
	// Generated file produced by the Adapter(s) and the writer.
	/**
	 * Generated dex filename (through adapter)
	 */
	public static final String FILENAME_ADAPTED_DEX = "adapted.dex";
	
	// Generated file produced by the writer to compare with the dex generated by the
	// Adapter(s).
	/**
	 * filename for expected dex
	 */
	public static final String FILENAME_EXPECTED_DEX = "expected.dex";
	
	// Temporary folders used by the tests for the Writer. 
	/**
	 * Folder of generated results
	 */
	public static final String TEMP_SUBFOLDER_GENERATED = "generated/";
	/**
	 * Folder of expected results
	 */
	public static final String TEMP_SUBFOLDER_EXPECTED = "expected/";
	
	// The temporary folders used to generate the .smali files by baksmali.
	/**
	 * 
	 */
	public static final String TEMP_FOLDER_ROOT = "tmpAsmDexTest/";
	/**
	 * 
	 */
	public static final String TEMP_FOLDER_GENERATED = TEMP_FOLDER_ROOT + TEMP_SUBFOLDER_GENERATED;
	/**
	 * 
	 */
	public static final String TEMP_FOLDER_EXPECTED = TEMP_FOLDER_ROOT + TEMP_SUBFOLDER_EXPECTED;

	/**
	 * Baksmali jar
	 */
	private static final String BAKSMALI_JAR = "lib/baksmali.jar";
	
	/** String to look after in order to find a Line information in the Baksmali output. */
	private static final String DEBUG_LINE_MNEMONIC = ".line";
	
	private static final String SMALI_EXTENSION = ".smali";
	
	
	/**
	 * Removes the temporary folder.
	 */
	public static void removeTemporaryFolder() {
		// We have to remove the last "/" at the end...
		String tempFolder = TEMP_FOLDER_ROOT.substring(0, TEMP_FOLDER_ROOT.length() - 1);
		File currentDir = new File("./");
		boolean found = false;
		File[] files = currentDir.listFiles();
		int size = files.length;
		int i = 0;
		
		// Looks for the temporary folder, and delete it.
		while (!found && (i < size)) {
			File innerFile = files[i];
			String innerFileName = innerFile.getName(); 
			if (innerFileName.contains(tempFolder)) {
				deleteFileOrDirectory(innerFile);
				found = true;
			} else {
				i++;
			}
		}
	}

	/**
	 * Deletes the file or directory and all its sub-content. 
	 * @param fileOrDirectory the file or directory to delete.
	 * @return true if the element has been deleted.
	 */
	private static boolean deleteFileOrDirectory(File fileOrDirectory) {
	    if (fileOrDirectory.isDirectory()) {
	        for (File innerFile: fileOrDirectory.listFiles()) {
	            if (!deleteFileOrDirectory(innerFile)) {
	                return false;
	            }
	        }
	    }
	    return fileOrDirectory.delete();
	}
	
	/**
	 * Counts the files in the given folder and its children. An extension may be given.
	 * @param extension extension (.smali, .dex ...), or null to count all the files.
	 * @return the number of files.
	 */
	public static int countFiles(File folderOrFile, String extension) {
		int count = 0;
		
		if (folderOrFile.isDirectory()) {
			// Folder.
	        for (File innerFile: folderOrFile.listFiles()) {
	        	count += countFiles(innerFile, extension);
	        }
	    } else {
	    	// File.
	    	if ((extension == null) || (folderOrFile.getName().endsWith(extension))) {
	    		count++;
	    	}
	    }
		
		return count;
	}
	
	/**
	 * Creates a file and fills it with an array of bytes, and returns it.
	 * @param bytes the bytes to put inside the file.
	 * @param pathAndFileName path and filename of the file to create.
	 * @throws IOException 
	 * @returns the created file.
	 * @throws IOException
	 */
	public static File createFileFromByteArray(byte[] bytes, String pathAndFileName) throws IOException {
		// Output to a file.
		File outputFile = new File(pathAndFileName);
		
		FileOutputStream outputStream = null;
		try {
			outputStream = new FileOutputStream(outputFile);
			outputStream.write(bytes);
		} catch (FileNotFoundException e) {
			e.printStackTrace();
		} finally {
			if (outputStream != null) { outputStream.close(); }
		}
		
		return outputFile;
	}
	
	/**
	 * Reads a file and return its content as a byte array.
	 * @param file the file to load.
	 * @return the byte array of its content.
	 * @throws IOException 
	 */
	public static byte[] readFile(File file) {
		byte[] bytes = null;
		
		ByteArrayOutputStream buffer = null;
		InputStream inputStream = null;
		try {
			inputStream = new FileInputStream(file);
			buffer = new ByteArrayOutputStream();
	    	
	    	byte[] dataRead = new byte[16384];
	    	int nbBytesRead;
	    	
	    	while ((nbBytesRead = inputStream.read(dataRead)) != -1) {
	    		buffer.write(dataRead, 0, nbBytesRead);
	    	}
	    	
	    	buffer.flush();
	    	bytes = buffer.toByteArray();
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
			if (buffer != null) { try {buffer.close();} catch (IOException e) { ; } }
			if (inputStream != null) { try {inputStream.close();} catch (IOException e) { ; }  }
		}
		
		return bytes;
	}
	
	/**
	 * Reads a file and return its content as a byte array.
	 * @param fileName the file to load.
	 * @return the byte array of its content.
	 * @throws IOException
	 */
	public static byte[] readFile(String fileName) throws IOException {
		return readFile(new File(fileName));
	}
	
	/**
	 * Returns an unsigned int from the given offset in the given array of bytes.
	 * @param bytes the array of bytes to read from.
	 * @param offset the offset of the first byte to read.
	 * @return the unsigned int.
	 */
	public static long readUInt(byte[] bytes, int offset) {
		return (long) ((bytes[offset] & 0xff) | ((bytes[offset + 1] & 0xff) << 8) |
				((bytes[offset + 2] & 0xff) << 16)) | ((long) (bytes[offset + 3] & 0xff) << 24);
		
	}
	
	/**
	 * Returns an unsigned short from the given offset in the given array of bytes.
	 * @param bytes the array of bytes to read from.
	 * @param offset the offset of the first byte to read.
	 * @return the unsigned short.
	 */
	public static int readUShort(byte[] bytes, int offset) {
		return ((bytes[offset] & 0xff) | ((bytes[offset + 1] & 0xff) << 8));	
	}
	
	/**
	 * Tests if the two given folders have identical content when testing the .smali files inside.
	 * @param folderName1 name of the first folder.
	 * @param folderName2 name of the first folder.
	 * @param skipLineNumbers true to skip the debug information about line numbers.
	 * @return true if the folders have identical content.
	 */
	public static boolean testSmaliFoldersEquality(String folderName1, String folderName2,
			boolean skipLineNumbers) {
		File folder1 = new File(folderName1);
		File folder2 = new File(folderName2);
		
		// Tests first if the same amount of smali files are created.
		int nbSmaliFiles1 = TestUtil.countFiles(folder1, SMALI_EXTENSION);
		int nbSmaliFiles2 = TestUtil.countFiles(folder2, SMALI_EXTENSION);
		assertEquals("Not the same amount of generated " + SMALI_EXTENSION + " files.", nbSmaliFiles1, nbSmaliFiles2);
		
		// Checks the content of each file from smali and the file generated.
		return testSmaliFoldersEquality(folder1, folder2, skipLineNumbers);
	}
	
	/**
	 * Tests if the two given folders have identical content when testing the .smali files inside.
	 * @param folder1 the first folder.
	 * @param folder2 the first folder.
	 * @param skipLineNumbers true to skip the debug information about line numbers.
	 * @return true if the folders have identical content.
	 */
	public static boolean testSmaliFoldersEquality(File folder1, File folder2,
			boolean skipLineNumbers) {
		boolean result = true;
		int i = 0;
		File[] files = folder1.listFiles();
		int nbFiles = files.length;
		while (result && (i < nbFiles)) {
			File innerFile = files[i];
            if (innerFile.isDirectory()) {
            	// Directory. Explores it, in synchronization with the second folder.
            	// To do so, the second folder is always built from the first one, with the
            	// beginning of the path replaced.
            	String path1 = folder1.getPath() + "/";
            	String path2 = folder2.getPath() + "/";
            	String innerFileString = innerFile.getPath();
            	innerFileString = innerFileString.substring(path1.length());
            	File secondFolder = new File(path2 + innerFileString);
            	result = testSmaliFoldersEquality(innerFile, secondFolder, skipLineNumbers);
            	assertTrue("Generated .smali files differ.", result);
            } else {
            	// Real file. Compares the two.
            	File secondFile = new File(folder2.getPath() + '/' + innerFile.getName());
            	result = TestUtil.compareSmaliFiles(innerFile, secondFile, skipLineNumbers);
            }
            i++;
        }
	    
        return result;
	}
	
	/**
	 * Compares two .smali files.
	 * @param file1 the first file.
	 * @param file2 the second file.
	 * @param skipLineNumbers true to skip the debug information about line numbers.
	 * @return true if the two files are identical.
	 */
	public static boolean compareSmaliFiles(File file1, File file2, boolean skipLineNumbers) {
		
		BufferedReader reader1 = null;
		BufferedReader reader2 = null;
		
		boolean equalLines = true;
		
		try {
			reader1 = new BufferedReader(new FileReader(file1));
			reader2 = new BufferedReader(new FileReader(file2));
			String line1, line2;
			
			while (equalLines && ((line1 = reader1.readLine()) != null)) {
					// Skips some debug information, if wanted. We don't test a possible end of file here
					// because .smali files should never ends with such pseudo-instruction.
					while (skipLineNumbers && line1 != null && line1.contains(DEBUG_LINE_MNEMONIC)) {
						line1 = reader1.readLine();
					}
					
					if ((line2 = reader2.readLine()) == null) {
						equalLines = false;
					} else {
						// Skips some debug information, if wanted. Same remark as above.
						while (skipLineNumbers && line2 != null && line2.contains(DEBUG_LINE_MNEMONIC)) {
							line2 = reader2.readLine();
						}
						equalLines = line1 == null ? line2 == null : line1.equals(line2);
					}
				}
				line1 = reader1.readLine();
				// If reader1 reaches the end, reader2 should also.
				if (equalLines && (line1 == null)) {
					line2 = reader2.readLine();
					equalLines = (line2 == null);
				}
			
			
		} catch (FileNotFoundException e) {
			e.printStackTrace();
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
			if (reader1 != null) { try {reader1.close();} catch (IOException e1) { ; } }
			if (reader2 != null) { try {reader2.close();} catch (IOException e1) { ; } }
		}

		
		return equalLines;
	}

	/**
	 * Creates a temporary folder within the current project, if it doesn't exist already.
	 */
	public static void createTemporaryFolder() {
		// Creates the temporary folder.
		createFolder(TEMP_FOLDER_ROOT);
	}
	
	/**
	 * Creates subfolders into the temporary folder.
	 * @param folders the subfolders (example, "test/", "conform/" etc.). Don't forget the "/".
	 */
	public static void createTemporaryFolders(String[] folders) {
		createTemporaryFolder();
		StringBuffer totalFolder = new StringBuffer(TEMP_FOLDER_ROOT);
		for (String folder : folders) {
			totalFolder.append(folder);
			createFolder(totalFolder.toString());
		}
	}
	
	/**
	 * Creates the given folder, if it doesn't exist.
	 * @param folder the folder to create.
	 */
	private static void createFolder(String folder) {
		File tempFolder = new File(folder);
		if (!tempFolder.exists()) {
			if (!tempFolder.mkdir()) {
				try { throw new IOException("Unable to create the temporary folder: " + folder);
				} catch (IOException e) { e.printStackTrace(); }
			}
		}
	}
	
	/**
	 * Retrieves a String from an InputStream.
	 * @param inputStream the InputStream from which to read.
	 * @return the String contained in the InputStream. 
	 * @throws IOException
	 */
	public static String getStringFromStream(InputStream inputStream) throws IOException {
		Writer writer = new StringWriter();

		char[] buffer = new char[1024];
		try {
			Reader reader = new BufferedReader(new InputStreamReader(inputStream));
			int n;
			while ((n = reader.read(buffer)) != -1) {
				writer.write(buffer, 0, n);
			}
		} finally {
			inputStream.close();
		}
		
		return writer.toString();
	}
	
	/**
	 * Tests the equality of the Maps structure of two given dex files. Only the quantity is tested,
	 * not the offsets.
	 * @param dexFile1 the first file to test.
	 * @param dexFile2 the first file to test.
	 * @return true if the Maps are equals.
	 * @throws IOException 
	 */
	public static boolean testMapDexFiles(File dexFile1, File dexFile2) throws IOException {
		int[][] map1 = getMap(dexFile1);
		int[][] map2 = getMap(dexFile2);
		return Arrays.deepEquals(map1, map2);
	}

	/**
	 * Returns the Map structure of the given dex file.
	 * @param dexFile the dex file to open.
	 * @return a two dimensional array containing, for each entry, the type and the count of its elements.
	 * @throws IOException 
	 */
	public static int[][] getMap(File dexFile) throws IOException {
		byte[] dataFile = TestUtil.readFile(dexFile);
		if (dataFile == null) return null;
		// Gets the offset of the Map in the Data section.
		int mapOffset = (int)TestUtil.readUInt(dataFile, Constants.MAP_OFFSET_IN_HEADER);
		
		// Gets the number of elements the Map consists of.
		int nbElements = (int)TestUtil.readUInt(dataFile, mapOffset);
		int currentOffset = mapOffset + 4; 
		// Reads all the elements, which consists of the type of them, the count of them,
		// and the offset (ignored).
		int[][] map = new int[nbElements][];
		for (int i = 0; i < nbElements; i++) {
			map[i] = new int[2];
			map[i][0] = TestUtil.readUShort(dataFile, currentOffset); // Gets type.
			currentOffset += 4; // Skips type short and unused short.
			map[i][1] = TestUtil.readUShort(dataFile, currentOffset); // Gets count.
			currentOffset += 8; // Skips count and offset;
		}
		
		return map;
	}
	
	/**
	 * Run baksmali with a given set of arguments. org.jf.baksmali.main.main
	 * @param args
	 * @return
	 */
	public static void baksmali(String [] args) throws IOException {
		File file = new File(BAKSMALI_JAR);
		URL url;
		try {
			url = new URL("jar:" + file.toURI().toString() + "!/");
			URLClassLoader jfl = new URLClassLoader(new URL[]{url});
			Class <?> baksmaliClass = jfl.loadClass("org.jf.baksmali.main");
			Method meth = baksmaliClass.getMethod("main", String[].class);
		    meth.invoke(null, (Object) args);
		} catch (Exception e) {
			throw new IOException("Cannot launch baksmali", e);
		} 
	}
}
