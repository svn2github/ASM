<?xml-stylesheet type="text/xsl" href="opcodes.xsl"?>
<opcodes>
<opcode>
<name>dup2_x2</name>
<short>duplicate two words and insert beneath  fourth word</short>
<stack><table>
<tr>
<td>
<b>Before </b>
</td>
<td><b>After</b></td></tr>
<tr>
<td>word1</td>
<td>word1</td></tr>
<tr>
<td>word2</td>
<td>word2</td></tr>
<tr>
<td>word3</td>
<td>word3</td></tr>
<tr>
<td>word4</td>
<td>word4</td></tr>
<tr>
<td>...</td>
<td>word1</td></tr>
<tr>
<td></td>
<td>word2</td></tr>
<tr>
<td></td>
<td>...</td></tr>
</table></stack>
<desc>Duplicates the top two-word item on the stack and inserts the duplicate
before the previous (two-word) item on the stack. Alternatively, this
instruction could be used to duplicate two single-word items and insert them
before the before the third two-word (or fourth single-word) item on the
stack.</desc>
<example><pre>
bipush 100
bipush 200
dconst_0

; stack now contains:

;     0.0 | double-word1
;     0.0 | double-word2
;     200   integer2-word1
;     100   integer1-word1
dup2_x2

; stack now contains:
;     0.0 | double-word1
;     0.0 | double-word2
;     200   integer2-word1
;     100   integer1-word1
;     0.0 | double-word1
;     0.0 | double-word2
</pre></example>
<bytecode><table>
<tr>
<td>
<b> Type </b>
</td>
<td><b>Description</b></td></tr>
<tr>
<td>
u1 
</td>
<td>dup2_x2
opcode = 0x5E (94)
</td></tr>
</table></bytecode>
<see>dup, dup2, dup_x1, dup2_x1</see>
</opcode>
<opcode>
<name>fastore</name>
<short>store in single-precision float array</short>
<stack><table>
<tr>
<td>
<b>Before </b>
</td>
<td><b>After</b></td></tr>
<tr>
<td>value</td>
<td>...</td></tr>
<tr>
<td>index</td>
<td>...</td></tr>
<tr>
<td>arrayref</td>
<td>...</td></tr>
<tr>
<td>...</td>
<td>...</td></tr>
</table></stack>
<desc>Takes a single-precision float from the stack and stores it in an array
of floats. <i>arrayref</i> is a reference to an array of single-precision
floats. <i>index</i> is an int. <i>value</i> is the single-precision float
<i>value</i> to be stored in the array. <i>arrayref</i>, <i>index</i> and
<i>value</i> are removed from the stack, and <i>value</i> is stored in the
array at the given <i>index</i>.</desc>
<exceptions>NullPointerException - <i>arrayref</i> is null

ArrayIndexOutOfBoundsException - <i>index</i> is &lt; 0 or &gt;=
arrayref.length</exceptions>
<bytecode><table>
<tr>
<td>
<b> Type </b>
</td>
<td><b>Description</b></td></tr>
<tr>
<td>
u1 
</td>
<td>fastore
opcode = 0x51 (81)
</td></tr>
</table></bytecode>
<see>iastore, lastore, dastore, aastore,
bastore, castore, sastore iaload,
laload, faload, daload, aaload,
baload, caload, saload</see>
<note>Array indices start at 0 (the first entry in the array is at
<i>index</i> 0).</note>
</opcode>
<opcode>
<name>fconst_&lt;f&gt;</name>
<short>push the single float 0.0, 1.0 or 2.0</short>
<stack><table>
<tr>
<td>
<b>Before </b>
</td>
<td><b>After</b></td></tr>
<tr>
<td>...</td>
<td>&lt;f&gt;</td></tr>
<tr>
<td></td>
<td>...</td></tr>
</table></stack>
<desc>fconst_&lt;f&gt; represents the series of opcodes
fconst_0, fconst_1, and fconst_2 that are used to
push the constant single-precision floats 0.0, 1.0 and 2.0 onto the stack.

For example, to push the single-precision float zero onto the stack, use:

<pre>

    fconst_0 ; push single-precision float 0 onto the stack

</pre>
Note
that you could also use:

<pre>

    ldc 0.0  ; push the float 0.0 onto the stack

</pre>
although
this instruction takes more space in the class file and is also less
efficient.</desc>
<example><pre>
fconst_0    ; push the float 0.0 onto the stack
fconst_1    ; push the float 1.0 onto the stack
fconst_2    ; push the float 2.0 onto the stack
</pre></example>
<bytecode><table>
<tr>
<td>
<b> Type </b>
</td>
<td><b>Description</b></td></tr>
<tr>
<td>
u1 
</td>
<td>fconst_0
opcode = 0x0B (11)
</td></tr>
<tr>
<td>
u1 
</td>
<td>fconst_1
opcode = 0x0C (12)
</td></tr>
<tr>
<td>
u1 
</td>
<td>fconst_2
opcode = 0x0D (13)
</td></tr>
</table></bytecode>
<see>bipush, sipush, ldc, ldc_w,
ldc2_w, aconst_null, iconst_m1,
lconst_&lt;l&gt; iconst_&lt;n&gt;, lconst_&lt;l&gt;,
dconst_&lt;d&gt;</see>
</opcode>
<opcode>
<name>freturn</name>
<short>return from method with float result</short>
<stack><table>
<tr>
<td>
<b>Before </b>
</td>
<td><b>After</b></td></tr>
<tr>
<td>return-value</td>
<td>n/a</td></tr>
<tr>
<td>...</td>
<td>...</td></tr>
</table></stack>
<desc>Pops a float from the top of the stack and pushes it onto the
operand stack of the invoker (i.e. the method which used
invokevirtual, invokespecial, invokestatic or
invokeinterface to call the currently executing method). All other
items on the current method's operand stack are discarded. If the current
method is marked as synchronized, then an implicit monitorexit instruction is
executed. Then the current method's frame is discarded, the invoker's frame is
reinstated, and control returns to the invoker. This instruction can only be
used in methods whose return type is float.</desc>
<bytecode><table>
<tr>
<td>
<b> Type </b>
</td>
<td><b>Description</b></td></tr>
<tr>
<td>
u1 
</td>
<td>freturn
opcode = 0xAE (174)
</td></tr>
</table></bytecode>
<see>lreturn, ireturn, dreturn, areturn,
return</see>
</opcode>
<opcode>
<name>fstore_&lt;n&gt;</name>
<short>store float in local variable &lt;n&gt;</short>
<stack><table>
<tr>
<td>
<b>Before </b>
</td>
<td><b>After</b></td></tr>
<tr>
<td>value</td>
<td>...</td></tr>
<tr>
<td>...</td>
<td>...</td></tr>
</table></stack>
<desc>Pops a single precision floating point number off the stack and stores
it in local variable &lt;n&gt;, where &lt;n&gt; is 0, 1, 2 or 3. &lt;n&gt; must
be a valid local variable number in the current frame.

'fstore_&lt;n&gt;' is functionally equivalent to 'fstore
&lt;n&gt;', although it is typically more efficient and also takes fewer
bytes in the bytecode.</desc>
<example><pre>
fstore_0        ;store float in local variable 0
fstore_1        ;store float in local variable 1
fstore_2        ;store float in local variable 2
fstore_3        ;store float in local variable 3

</pre></example>
<bytecode><table>
<tr>
<td>
<b> Type </b>
</td>
<td><b>Description</b></td></tr>
<tr>
<td>
u1 
</td>
<td>fstore_0
opcode = 0x43 (67)
</td></tr>
<tr>
<td>
u1 
</td>
<td>fstore_1
opcode = 0x44 (68)
</td></tr>
<tr>
<td>
u1 
</td>
<td>fstore_2
opcode = 0x45 (69)
</td></tr>
<tr>
<td>
u1 
</td>
<td>fstore_3
opcode = 0x46 (70)
</td></tr>
</table></bytecode>
<see>istore, fstore, astore, dstore,
lstore</see>
</opcode>
<opcode>
<name>getfield</name>
<short>get value of  object  field</short>
<stack><table>
<tr>
<td>
<b>Before </b>
</td>
<td><b>After</b></td></tr>
<tr>
<td>objectref</td>
<td>value</td></tr>
<tr>
<td>...</td>
<td>...</td></tr>
</table></stack>
<desc>getfield pops <i>objectref</i> (a reference to an object) from
the stack, retrieves the value of the field identified by &lt;field-spec&gt;
from <i>objectref</i>, and pushes the one-word or two-word value onto the
operand stack. 

For example, if you have the class:

<pre>
    package xyz;
    class Point {
        public int xCoord, yCoord;
    };

</pre>
Then,
assuming p is an instance of the class Point, writing the Java expression:

<pre>
    int x = p.xCoord;
</pre>
generates
a call to getfield like:

<pre>
    aload_1                      ; push object in local varable 1 (i.e. p) onto the stack
    getfield xyz/Point/xCoord I  ; get the value of p.xCoord, which is an int
    istore_2                     ; store the int value in local variable 2 (x)
</pre>
In
Jasmin, getfield takes two parameters, &lt;field-spec&gt; and
&lt;descriptor&gt;. &lt;field-spec&gt; gives <i>classname</i>, the name of the
class that defines the field, as well as <i>fieldname</i>, as the name of the
field itself. In the example above, the &lt;field-spec&gt; is
"xyz/Point/xCoord", indicating that the <i>classname</i> is "xyz/Point" and the
<i>fieldname</i> is "xCoord". &lt;descriptor&gt; describes the type of data
held in the field, and is a standard Java type descriptor (see Chapter 4 for a
full description of type descriptors). In the example above, &lt;descriptor&gt;
is "I", since the field holds an integer.  

getfield first resolves <i>classname</i> to a Java class. Then it
locates the <i>fieldname</i> in that class, determining the <i>width</i> of the
field (in bytes) and its <i>offset</i> (in bytes) from the base of the object
data. The type of the field must match &lt;descriptor&gt;. See Chapter 7 for
more on how fields are resolved

To retrieve the value for the field, getfield obtains the bytes
starting at <i>offset</i> and extending for <i>width</i> bytes from the start
of <i>objectref</i>'s instance data, expands it to either a 4-byte or 8-byte
value, and pushes the value onto the operand stack.</desc>
<exceptions>NullPointerException - <i>objectref</i> is null</exceptions>
<bytecode><table>
<tr>
<td>
<b> Type </b>
</td>
<td><b>Description</b></td></tr>
<tr>
<td>
u1 
</td>
<td>getfield
opcode = 0xB4 (180)
</td></tr>
<tr>
<td>
u2 
</td>
<td>index</td></tr>
</table></bytecode>
<see>putfield, putstatic, getstatic</see>
<note>Fields cannot be overriden, although they can be 'shadowed'. For
example, with the two classes:

<pre>
    class A { int x; }
and
    class B extends A { int x; }
</pre>
instances
of B will have storage for both the field "A/x" and the field "B/x". Which
field is accessed is determined by the class name given in
&lt;field-spec&gt;.</note>
</opcode>
<opcode>
<name>getstatic</name>
<short>get value of static field</short>
<stack><table>
<tr>
<td>
<b>Before </b>
</td>
<td><b>After</b></td></tr>
<tr>
<td>...</td>
<td>value</td></tr>
<tr>
<td></td>
<td>...</td></tr>
</table></stack>
<desc>getstatic pops <i>objectref</i> (a reference to an object) from
the stack, retrieves the value of the static field (also known as a class
field) identified by &lt;field-spec&gt; from <i>objectref</i>, and pushes the
one-word or two-word value onto the operand stack. 

For example, when you write the Java expression:

<pre>
    PrintStream obj = java.lang.System.out;
</pre>
this
generates a call to getstatic like:

<pre>
    getstatic java/lang/System/out Ljava/io/PrintStream;
    astore_1   ; store the object reference result in local variable 1
</pre>
In
Jasmin, getstatic takes two parameters, &lt;field-spec&gt; and
&lt;descriptor&gt;. &lt;field-spec&gt; provides <i>classname</i>, the name of
the class that defines the static field, as well <i>fieldname</i>, as the name
of the field. In the example above, the &lt;field-spec&gt; is
"java/lang/System/out", indicating that the <i>classname</i> is
"java/lang/System" and the <i>fieldname</i> is "out".  &lt;descriptor&gt;
indicates the type of data held in the field, and is a standard Java type
descriptor (see Chapter 4). In the example above, &lt;descriptor&gt; is
"Ljava/io/PrintStream;", i.e. a reference to a PrintStream object.

getstatic first resolves <i>classname</i> into a Java class. Then it
locates the <i>fieldname</i> in that class, determining the <i>width</i> of the
field (in bytes) and its <i>offset</i> (in bytes) from the base of the class's
static data. The type of the field must match &lt;descriptor&gt;. See Chapter 7
for more on how fields are resolved

To retrieve the value for the field, getstatic obtains the bytes
starting at <i>offset</i> and extending for <i>width</i> bytes from the start
of the class's static  data, expands it to either a 4-byte or 8-byte value, and
pushes the value onto the operand stack.</desc>
<bytecode><table>
<tr>
<td>
<b> Type </b>
</td>
<td><b>Description</b></td></tr>
<tr>
<td>
u1 
</td>
<td>getstatic
opcode = 0xB2 (178)
</td></tr>
<tr>
<td>
u2 
</td>
<td>index</td></tr>
</table></bytecode>
<see>putfield, getfield, putstatic</see>
<note>Fields cannot be overriden, although they can be 'shadowed'. For
example, with the two classes:

<pre>
    class A { static int x; }
and
    class B extends A { static int x; }
</pre>
then
the runtime system will allocate storage for both the static field "A/x" and
the static field "B/x". Which field is accessed is determined by the class name
given in &lt;field-spec&gt;.</note>
</opcode>
<opcode>
<name>arraylength</name>
<short>get length of array</short>
<stack><table>
<tr>
<td>
<b>Before </b>
</td>
<td><b>After</b></td></tr>
<tr>
<td>arrayref</td>
<td>length</td></tr>
<tr>
<td>...</td>
<td>...</td></tr>
</table></stack>
<desc>Removes <i>arrayref</i> (a reference to an array) from the stack and
replaces it with the length of the array (an int). For multi-dimensional
arrays, the length of the first dimension is returned.</desc>
<exceptions>NullPointerException - <i>arrayref</i> is null.</exceptions>
<bytecode><table>
<tr>
<td>
<b> Type </b>
</td>
<td><b>Description</b></td></tr>
<tr>
<td>
u1 
</td>
<td>arraylength
opcode = 0xBE(190)
</td></tr>
</table></bytecode>
</opcode>
<opcode>
<name>iastore</name>
<short>store in integer array</short>
<stack><table>
<tr>
<td>
<b>Before </b>
</td>
<td><b>After</b></td></tr>
<tr>
<td>value</td>
<td>...</td></tr>
<tr>
<td>index</td>
<td>...</td></tr>
<tr>
<td>arrayref</td>
<td>...</td></tr>
<tr>
<td>...</td>
<td>...</td></tr>
</table></stack>
<desc>Takes an int from the stack and stores it in an array of ints.
<i>arrayref</i> is a reference to an array of ints. <i>index</i> is an int.
<i>value</i> is the int value to be stored in the array. <i>arrayref</i>,
<i>index</i> and <i>value</i> are removed from the stack, and <i>value</i> is
stored in the array at the given <i>index</i>.</desc>
<exceptions>NullPointerException - <i>arrayref</i> is null

ArrayIndexOutOfBoundsException - <i>index</i> is &lt; 0 or &gt;=
arrayref.length</exceptions>
<bytecode><table>
<tr>
<td>
<b> Type </b>
</td>
<td><b>Description</b></td></tr>
<tr>
<td>
u1 
</td>
<td>iastore
opcode = 0x4F (79)
</td></tr>
</table></bytecode>
<see>lastore, fastore, dastore, aastore,
bastore, castore, sastore, iaload,
laload, faload, daload, aaload,
baload, caload, saload</see>
<note>Array indices start at 0 (the first entry in the array is at
<i>index</i> 0).</note>
</opcode>
<opcode>
<name>iconst_&lt;n&gt;</name>
<short>push the integer constant 0, 1, 2, 3, 4 or 5</short>
<stack><table>
<tr>
<td>
<b>Before </b>
</td>
<td><b>After</b></td></tr>
<tr>
<td>...</td>
<td>&lt;n&gt;</td></tr>
<tr>
<td></td>
<td>...</td></tr>
</table></stack>
<desc>iconst_&lt;n&gt; represents the series of opcodes iconst_0,
iconst_1, iconst_2, iconst_3, iconst_4 and iconst_5. These are used to push the
constant ints 0 through 5 onto the stack. For example, to push the int zero
onto the stack, use:

<pre>
iconst_0 ; push 0 onto the stack.
</pre>
Note
that you could also use:

<pre>
bipush 0 ; push 0 onto the stack
</pre>
or


<pre>
sipush 0 ; push 0 onto the stack
</pre>
or

<pre>
ldc 0 ; push 0 onto the stack
</pre>
although
these instructions are typically less efficient than the equivalent
iconst_&lt;n&gt; and also take up more bytes in the class file.</desc>
<example><pre>

iconst_0  ; push 0 onto the stack
iconst_1  ; push 1 onto the stack
iconst_2  ; push 2 onto the stack
iconst_3  ; push 3 onto the stack
iconst_4  ; push 4 onto the stack
iconst_5  ; push 5 onto the stack

</pre></example>
<bytecode><table>
<tr>
<td>
<b> Type </b>
</td>
<td><b>Description</b></td></tr>
<tr>
<td>
u1 
</td>
<td>iconst_0
opcode = 0x03 (3)
</td></tr>
<tr>
<td>
u1 
</td>
<td>iconst_1
opcode = 0x04 (4)
</td></tr>
<tr>
<td>
u1 
</td>
<td>iconst_2
opcode = 0x05 (5)
</td></tr>
<tr>
<td>
u1 
</td>
<td>iconst_3
opcode = 0x06 (6)
</td></tr>
<tr>
<td>
u1 
</td>
<td>iconst_4
opcode = 0x07 (7)
</td></tr>
<tr>
<td>
u1 
</td>
<td>iconst_5
opcode = 0x08 (8)
</td></tr>
</table></bytecode>
<see>bipush, sipush, ldc, ldc_w,
ldc2_w, aconst_null, iconst_m1,
lconst_&lt;l&gt;, fconst_&lt;f&gt;,
dconst_&lt;d&gt;</see>
</opcode>
<opcode>
<name>iconst_m1</name>
<short>push the integer constant -1</short>
<stack><table>
<tr>
<td>
<b>Before </b>
</td>
<td><b>After</b></td></tr>
<tr>
<td>...</td>
<td>-1</td></tr>
<tr>
<td></td>
<td>...</td></tr>
</table></stack>
<desc>This instruction pushes the int -1 onto the operand stack.</desc>
<bytecode><table>
<tr>
<td>
<b> Type </b>
</td>
<td><b>Description</b></td></tr>
<tr>
<td>
u1 
</td>
<td>iconst_m1
opcode = 0x02 (2)
</td></tr>
</table></bytecode>
<see>bipush, sipush, ldc, ldc_w,
ldc2_w, aconst_null, iconst_&lt;n&gt;,
lconst_&lt;l&gt;, fconst_&lt;f&gt;,
dconst_&lt;d&gt;</see>
<note>You could also use bipush -1, sipush -1 or ldc
-1 to achieve the same effect, although iconst_m1 is typically
more efficient and uses fewer bytes in the bytecode.</note>
</opcode>
<opcode>
<name>if_acmpeq</name>
<short>jump if two object references are equal</short>
<stack><table>
<tr>
<td>
<b>Before </b>
</td>
<td><b>After</b></td></tr>
<tr>
<td>value1</td>
<td>...</td></tr>
<tr>
<td>value2</td>
<td>...</td></tr>
<tr>
<td>...</td>
<td>...</td></tr>
</table></stack>
<desc>if_acmpeq pops the top two object references off the stack and
compares them. If the two object references are equal (i.e. if they both refer
to the same object), execution branches to the address (<i>pc</i> +
<i>branchoffset</i>), where <i>pc</i> is the address of the if_acmpeq
opcode in the bytecode and <i>branchoffset</i> is a 16-bit signed integer
parameter following the if_acmpeq opcode in the bytecode. If the
object references refer to different objects, execution continues at the next
instruction.

If you are using Jasmin, <i>branchoffset</i> is computed for you from the
address of &lt;label&gt;.</desc>
<example><pre>
    aload_1         ; push the object reference in local variable 1 onto stack
    aload_2         ; push the object reference in local variable 2 onto stack
    if_acmpeq Label ; if the two references on the stack are identical, jump to Label
    return          ; return if not equal
Label:
    ; execution continues here if local variables 1 and 2 refer to the same object

</pre></example>
<bytecode><table>
<tr>
<td>
<b> Type </b>
</td>
<td><b>Description</b></td></tr>
<tr>
<td>
u1 
</td>
<td>if_acmpeq
opcode = 0xA5 (165)
</td></tr>
<tr>
<td>
s2 
</td>
<td><i>branchoffset</i></td></tr>
</table></bytecode>
<see>if_acmpne</see>
<note>Addresses are measured in bytes from the start of the bytecode (i.e.
address 0 is the first byte in the bytecode of the currently executing
method).</note>
</opcode>
<opcode>
<name>if_acmpne</name>
<short>jump if two object references are not equal</short>
<stack><table>
<tr>
<td>
<b>Before </b>
</td>
<td><b>After</b></td></tr>
<tr>
<td>value1</td>
<td>...</td></tr>
<tr>
<td>value2</td>
<td>...</td></tr>
<tr>
<td>...</td>
<td>...</td></tr>
</table></stack>
<desc>if_acmpne pops the top two object references off the stack and
compares them. If the two object references are not equal (i.e. if they refer
to different objects), execution branches to the address (<i>pc</i> +
<i>branchoffset</i>), where <i>pc</i> is the address of the if_acmpne
opcode in the bytecode and <i>branchoffset</i> is a 16-bit signed integer
parameter following the if_acmpne opcode in the bytecode. If the
object references refer to the same object, execution continues at the next
instruction. 

If you are using Jasmin, <i>branchoffset</i> is computed for you from the
address of &lt;label&gt;.</desc>
<example><pre>
    aload_1         ; push the object reference in local variable 1 onto stack
    aload_2         ; push the object reference in local variable 2 onto stack
    if_acmpne Label ; if the two references on the stack differ, jump to Label
    return          ; return if local variables 1 and 2 are the same object
Label:
    ; execution continues here if local variables 1 and 2 refer to the different  objects
</pre></example>
<bytecode><table>
<tr>
<td>
<b> Type </b>
</td>
<td><b>Description</b></td></tr>
<tr>
<td>
u1 
</td>
<td>if_acmpne
opcode = 0xA6 (166)
</td></tr>
<tr>
<td>
s2 
</td>
<td><i>branchoffset</i></td></tr>
</table></bytecode>
<see>if_icmpne, if_icmplt, if_icmpgt,
if_icmple, if_icmpge</see>
<note>Addresses are measured in bytes from the start of the bytecode (i.e.
address 0 is the first byte in the bytecode of the currently executing
method).</note>
</opcode>
<opcode>
<name>if_icmpeq</name>
<short>jump if two integers are equal</short>
<stack><table>
<tr>
<td>
<b>Before </b>
</td>
<td><b>After</b></td></tr>
<tr>
<td>value1</td>
<td>...</td></tr>
<tr>
<td>value2</td>
<td>...</td></tr>
<tr>
<td>...</td>
<td>...</td></tr>
</table></stack>
<desc>if_icmpeq pops the top two ints off the stack and compares
them. If the two integers are equal, execution branches to the address
(<i>pc</i> + <i>branchoffset</i>), where <i>pc</i> is the address of the
if_icmpeq opcode in the bytecode and <i>branchoffset</i> is a 16-bit
signed integer parameter following the if_icmpeq opcode in the
bytecode. If the integers are not equal, execution continues at the next
instruction.

If you are using Jasmin, <i>branchoffset</i> is computed for you from the
address of &lt;label&gt;.</desc>
<example><pre>
    bipush 2        ; push the int 2 onto the stack
    iload_1         ; push the int value in local variable 1 onto the stack
    if_icmpeq Label ; if the value of local variable 1 equals 2, jump to Label
    return          ; return if not equal
Label:
    ; execution continues here if local variable 1 equals 2...

</pre></example>
<bytecode><table>
<tr>
<td>
<b> Type </b>
</td>
<td><b>Description</b></td></tr>
<tr>
<td>
u1 
</td>
<td>if_icmpeq
opcode = 0x9F (159)
</td></tr>
<tr>
<td>
s2 
</td>
<td><i>branchoffset</i></td></tr>
</table></bytecode>
<see>if_icmpne, if_icmplt, if_icmpgt,
if_icmple, if_icmpge</see>
<note>Addresses are measured in bytes from the start of the bytecode (i.e.
address 0 is the first byte in the bytecode of the currently executing
method).</note>
</opcode>
<opcode>
<name>if_icmpge</name>
<short>jump if one integer is greater than or equal to
another</short>
<stack><table>
<tr>
<td>
<b>Before </b>
</td>
<td><b>After</b></td></tr>
<tr>
<td>value1</td>
<td>...</td></tr>
<tr>
<td>value2</td>
<td>...</td></tr>
<tr> <td></td>
<td>...</td></tr>
</table></stack>
<desc>if_icmpge pops the top two ints off the stack and compares
them. If <i>value2</i> is greater than or equal to <i>value1</i>, execution
branches to the address (<i>pc</i> + <i>branchoffset</i>), where <i>pc</i> is
the address of the if_icmpge opcode in the bytecode and
<i>branchoffset</i> is a 16-bit signed integer parameter following the
if_icmpge opcode in the bytecode. If <i>value2</i> is less than
<i>value1</i>, execution continues at the next instruction.

If you are using Jasmin, <i>branchoffset</i> is computed for you from the
address of &lt;label&gt;.</desc>
<example><pre>
    iload_1         ; push the int value in local variable 1 onto the stack
    bipush 2        ; push the int 2 onto the stack
    if_icmpge Label ; if the value of local variable 1 &gt;= 2, jump to Label
    return          ; return if local variable 1 &lt; 2
Label:
    ; execution continues here if local variable 1 &gt;= 2...
</pre></example>
<bytecode><table>
<tr>
<td>
<b> Type </b>
</td>
<td><b>Description</b></td></tr>
<tr>
<td>
u1 
</td>
<td>if_icmpge
opcode = 0xA2 (162)
</td></tr>
<tr>
<td>
s2 
</td>
<td><i>branchoffset</i></td></tr>
</table></bytecode>
<see>if_icmpeq, if_icmpne, if_icmplt,
if_icmpgt, if_icmple</see>
<note>Addresses are measured in bytes from the start of the bytecode (i.e.
address 0 is the first byte in the bytecode of the currently executing
method).</note>
</opcode>
<opcode>
<name>if_icmpgt</name>
<short>jump if one integer is greater than another</short>
<stack><table>
<tr>
<td>
<b>Before </b>
</td>
<td><b>After</b></td></tr>
<tr>
<td>value1</td>
<td>...</td></tr>
<tr>
<td>value2</td>
<td>...</td></tr>
<tr> <td></td>
<td>...</td></tr>
</table></stack>
<desc>if_icmpgt pops the top two ints off the stack and compares
them. If <i>value2</i> is greater than <i>value1</i>, execution branches to the
address (<i>pc</i> + <i>branchoffset</i>), where <i>pc</i> is the address of
the if_icmpgt opcode in the bytecode and <i>branchoffset</i> is a
16-bit signed integer parameter following the if_icmpgt opcode in the
bytecode. If <i>value2</i> is less than or equal to <i>value1</i>, execution
continues at the next instruction.

If you are using Jasmin, <i>branchoffset</i> is computed for you from the
address of &lt;label&gt;.</desc>
<example><pre>
    iload_1         ; push the integer value of local variable 1 onto the stack
    bipush 2        ; push the integer 2 onto the stack
    if_icmpgt Label ; if the value of local variable 1 is greater than 2, jump to Label
    return          ; return if local variable 1 &lt;= 2
Label:
    ; execution continues here if local variable 1 is geater than 2...
</pre></example>
<bytecode><table>
<tr>
<td>
<b> Type </b>
</td>
<td><b>Description</b></td></tr>
<tr>
<td>
u1 
</td>
<td>if_icmpgt
opcode = 0xA3 (163)
</td></tr>
<tr>
<td>
s2 
</td>
<td><i>branchoffset</i></td></tr>
</table></bytecode>
<see>if_icmpeq, if_icmpne, if_icmplt,
if_icmple, if_icmpge</see>
<note>Addresses are measured in bytes from the start of the bytecode (i.e.
address 0 is the first byte in the bytecode of the currently executing
method).</note>
</opcode>
<opcode>
<name>if_icmple</name>
<short>jump if one integer is less than or equal to another</short>
<stack><table>
<tr>
<td>
<b>Before </b>
</td>
<td><b>After</b></td></tr>
<tr>
<td>value1</td>
<td>...</td></tr>
<tr>
<td>value2</td>
<td>...</td></tr>
<tr> <td></td>
<td>...</td></tr>
</table></stack>
<desc>if_icmple pops the top two ints off the stack and compares
them. If <i>value2</i> is less than or equal to <i>value1</i>, execution
branches to the address (<i>pc</i> + <i>branchoffset</i>), where <i>pc</i> is
the address of the if_icmple opcode in the bytecode and
<i>branchoffset</i> is a 16-bit signed integer parameter following the
if_icmple opcode in the bytecode. If <i>value2</i> is greater than
<i>value1</i>, execution continues at the next instruction.

If you are using Jasmin, <i>branchoffset</i> is computed for you from the
address of &lt;label&gt;.</desc>
<example><pre>
    iload_1         ; push the int value in local variable 1 onto the stack
    bipush 2        ; push the int 2 onto the stack
    if_icmple Label ; if the value of local variable 1 is &lt;= 2, jump to Label
    return          ; return if local variable 1 is greater than 2
Label:
    ; execution continues here if local variable 1 is less than or equal to 2...

</pre></example>
<bytecode><table>
<tr>
<td>
<b> Type </b>
</td>
<td><b>Description</b></td></tr>
<tr>
<td>
u1 
</td>
<td>if_icmple
opcode = 0xA4 (164)
</td></tr>
<tr>
<td>
s2 
</td>
<td><i>branchoffset</i></td></tr>
</table></bytecode>
<see>if_icmpeq, if_icmpne, if_icmplt,
if_icmpgt, if_icmpge</see>
<note>Addresses are measured in bytes from the start of the bytecode (i.e.
address 0 is the first byte in the bytecode of the currently executing
method).</note>
</opcode>
<opcode>
<name>if_icmplt</name>
<short>jump if one integer is less than another</short>
<stack><table>
<tr>
<td>
<b>Before </b>
</td>
<td><b>After</b></td></tr>
<tr>
<td>value1</td>
<td>...</td></tr>
<tr>
<td>value2</td>
<td>...</td></tr>
<tr> <td></td>
<td>...</td></tr>
</table></stack>
<desc>if_icmplt pops the top two ints off the stack and compares
them. If <i>value2</i> is less than <i>value1</i>, execution branches to the
address (<i>pc</i> + <i>branchoffset</i>), where <i>pc</i> is the address of
the if_icmplt opcode in the bytecode and <i>branchoffset</i> is a
16-bit signed integer parameter following the if_icmplt opcode in the
bytecode. If <i>value2</i> is greater than or equal to <i>value1</i>, execution
continues at the next instruction. 

If you are using Jasmin, <i>branchoffset</i> is computed for you from the
address of &lt;label&gt;.</desc>
<example><pre>
    iload_1         ; push the int value in local variable 1 onto the stack
    bipush 2        ; push the int 2 onto the stack
    if_icmplt Label ; if the value of local variable 1 is &lt;= 2, jump to Label
    return          ; return if local variable 1 is greater than 2
Label:
    ; execution continues here if local variable 1 is less than or equal to 2...
</pre></example>
<bytecode><table>
<tr>
<td>
<b> Type </b>
</td>
<td><b>Description</b></td></tr>
<tr>
<td>
u1 
</td>
<td>if_icmplt
opcode = 0xA1 (161)
</td></tr>
<tr>
<td>
s2 
</td>
<td><i>branchoffset</i></td></tr>
</table></bytecode>
<see>if_icmpeq, if_icmpne, if_icmpgt,
if_icmple, if_icmpge</see>
<note>Addresses are measured in bytes from the start of the bytecode (i.e.
address 0 is the first byte in the bytecode of the currently executing
method).</note>
</opcode>
<opcode>
<name>astore_&lt;n&gt;</name>
<short>store  object reference in local variable &lt;n&gt;</short>
<stack><table>
<tr>
<td>
<b>Before </b>
</td>
<td><b>After</b></td></tr>
<tr>
<td>objectref</td>
<td>...</td></tr>
<tr>
<td>...</td>
<td>...</td></tr>
</table></stack>
<desc>Pops objectref (a reference to an object or array) off the stack and
stores it in local variable &lt;n&gt;, where &lt;n&gt; is 0, 1, 2 or 3.
&lt;n&gt; must be a valid local variable number in the current frame.

'astore_&lt;n&gt;' is functionally equivalent to 'astore
&lt;n&gt;', although it is typically more efficient and also takes fewer
bytes in the bytecode.</desc>
<example><pre>
astore_0        ; store reference in local variable 0
astore_1        ; store reference in local variable 1
astore_2        ; store reference in local variable 2
astore_3        ; store reference in local variable 3

</pre></example>
<bytecode><table>
<tr>
<td>
<b> Type </b>
</td>
<td><b>Description</b></td></tr>
<tr>
<td>
u1 
</td>
<td>astore_0
opcode = 0x4B (75)
</td></tr>
<tr>
<td>
u1 
</td>
<td>astore_1
opcode = 0x4C (76)
</td></tr>
<tr>
<td>
u1 
</td>
<td>astore_2
opcode = 0x4D (77)
</td></tr>
<tr>
<td>
u1 
</td>
<td>astore_3
opcode = 0x4E (78)
</td></tr>
</table></bytecode>
<see>astore, istore, fstore, dstore,
lstore, aload, iload, fload,
dload, lload</see>
<note>astore can also be used to store a returnAddress in a local
variable. See the jsr instruction for more details.</note>
</opcode>
<opcode>
<name>if_icmpne</name>
<short>jump if two integers are not equal</short>
<stack><table>
<tr>
<td>
<b>Before </b>
</td>
<td><b>After</b></td></tr>
<tr>
<td>value1</td>
<td>...</td></tr>
<tr>
<td>value2</td>
<td>...</td></tr>
<tr>
<td>...</td>
<td>...</td></tr>
</table></stack>
<desc>if_icmpne pops the top two ints off the stack and compares
them. If the two integers are not equal, execution branches to the address
(<i>pc</i> + <i>branchoffset</i>), where <i>pc</i> is the address of the
if_icmpne opcode in the bytecode and <i>branchoffset</i> is a 16-bit
signed integer parameter following the if_icmpne opcode in the
bytecode. If the integers are equal, execution continues at the next
instruction.

If you are using Jasmin, <i>branchoffset</i> is computed for you from the
address of &lt;label&gt;.</desc>
<example><pre>
    bipush 2        ; push the int 2 onto the stack
    iload_1         ; push the int value in local variable 1 onto the stack
    if_icmpne Label ; if the value of local variable 1 does not equal 2, jump to Label
    return          ; return if local variable 1 equals 2
Label:
    ; execution continues here if local variable 1 does not equals 2...
</pre></example>
<bytecode><table>
<tr>
<td>
<b> Type </b>
</td>
<td><b>Description</b></td></tr>
<tr>
<td>
u1 
</td>
<td>if_icmpne
opcode = 0xA0 (160)
</td></tr>
<tr>
<td>
s2 
</td>
<td><i>branchoffset</i></td></tr>
</table></bytecode>
<see>if_icmpeq, if_icmplt, if_icmpgt,
if_icmple, if_icmpge</see>
<note>Addresses are measured in bytes from the start of the bytecode (i.e.
address 0 is the first byte in the bytecode of the currently executing
method).</note>
</opcode>
<opcode>
<name>instanceof</name>
<short>test class of object</short>
<stack><table>
<tr>
<td>
<b>Before </b>
</td>
<td><b>After</b></td></tr>
<tr>
<td>objectref</td>
<td>int-result</td></tr>
<tr>
<td>...</td>
<td>...</td></tr>
</table></stack>
<desc>The instanceof instruction is used to implement the Java
language's instanceof operator, which tests whether an object
reference or array belongs to a given class.

instanceof takes a single parameter, &lt;type&gt;.
&lt;type&gt; is either the name of a Java class, or it is the type
descriptor of an array. 

At runtime, &lt;type&gt; is resolved (Chapter 7 describes how classes are
resolved). Next, instanceof pops <i>objectref</i> (a reference to an
object) off the top of the operand stack. If <i>objectref</i> is an instance of
&lt;type&gt; or one of &lt;type&gt;'s subclasses, the int 1
is pushed onto the stack, otherwise the int 0 is pushed onto the stack. If
<i>objectref</i> is null, the result is always 0. If
&lt;type&gt; is an interface, int-result will be 1 if <i>objectref</i>
implements that interface, and 0 if <i>objectref</i> does not implement the
interface.</desc>
<example><pre>
; using instanceof to test for a String:
    aload_1        ; push object reference in local variable 1 onto stack
    instanceof java/lang/String;      ; test if item on stack is a String
    ifne HaveString                   ; if so, goto HaveString
    return                            ; otherwise, return
HaveString:
    ; if this point is reached, local variable 1 holds a string

; this example uses instanceof to test if local variable 1 holds
; an integer array
    aload_1                  ; push local variable 1 onto the stack
    instanceof [I            ; test if the top item on the stack is an integer array
    ifne HaveIntegerArray    ; if so, jump to HaveIntegerArray
    return                   ; simply return if local variable 1 is not an int array
HaveIntegerArray:            
    ; if this point is reached, local variable 1 holds an integer array

; you can also use instanceof to test that objects implement a given interface,
; e.g.
    aload_1                  ; push local variable 1 onto the stack
    instanceof java/lang/Runnable  ; test if it implements the Runnable interface
    ifne HaveARunnable       ; if so, jump to HaveARunnable
    return                   ; otherwise return
HaveARunnable:            
    ; if this point is reached, local variable 1 holds a reference to an object
    ; that implements the Runnable interface.

</pre></example>
<bytecode><table>
<tr>
<td>
<b> Type </b>
</td>
<td><b>Description</b></td></tr>
<tr>
<td>
u1 
</td>
<td>instanceof
opcode = 0xC1 (193)
</td></tr>
<tr>
<td>
u2 
</td>
<td>index</td></tr>
</table></bytecode>
<see>checkcast</see>
</opcode>
<opcode>
<name>invokeinterface</name>
<short>invoke an interface method</short>
<stack><table>
<tr>
<td>
<b>Before </b>
</td>
<td><b>After</b></td></tr>
<tr>
<td>argN</td>
<td>[result]</td></tr>
<tr>
<td>---</td>
<td>...</td></tr>
<tr>
<td>arg2</td>
<td>...</td></tr>
<tr>
<td>arg1</td>
<td>...</td></tr>
<tr>
<td>objectref</td>
<td>...</td></tr>
<tr>
<td>...</td>
<td>...</td></tr>
</table></stack>
<desc>invokeinterface is used to invoke a method declared within a
Java interface. For example, if you have the Java code:

<pre>
void test(Enumeration enum) {
    boolean x = enum.hasMoreElements();
    ...
}
</pre>
invokeinterface
will be used to call the hasMoreElements() method, since Enumeration is a Java
interface, and hasMoreElements() is a method declared in that interface. In
this example, the Java compiler generates code like:

<pre>
    aload_1            ; push local variable 1 (i.e. the enum object) onto the stack
    ; call hasMoreElements()
    invokeinterface java/util/Enumeration/hasMoreElements()Z 1  
    istore_2           ; store the boolean result in local variable 2 (i.e. x)
</pre>
Which
particular implementation of hasMoreElements() is used will depend on the type
of object held in local variable 1 at runtime. 

Before performing the method invokation, the interface and the method
identified by &lt;method-spec&gt; are resolved. See Chapter 9 for a description
of how methods are resolved.

To invoke an interface method, the interpreter first pops &lt;n&gt; items off
the operand stack, where &lt;n&gt; is an 8-bit unsigned integer parameter taken
from the bytecode. The first of these items is <i>objectref</i>, a reference to
the object whose method is being called. The rest of the items are the
arguments for the method. 

Then the class of the object referred to by <i>objectref</i> is retrieved. This
class must implement the interface named in &lt;method-spec&gt;. The method
table for this class is searched, and the method with the given
<i>methodname</i> and <i>descriptor </i>is located.

Once the method has been located, invokeinterface calls the method.
First, if the method is marked as synchronized, the monitor associated
with <i>objectref</i> is entered. Next, a new stack frame is established on the
callstack. Then the arguments for the method are placed in the local variable
slots of the new stack frame structure. arg1 is stored in local variable 1,
arg2 is stored in local variable 2 and so on. <i>objectref</i> is stored in
local variable 0, the local variable used by the special Java variable
this. Execution continues at the first instruction in the bytecode of
the new method. 

Methods marked as native are handled slightly differently. For native
methods, the runtime system locates the platform-specific code for the method,
loading it and linking it into the JVM if necessary. Then the native method
code is executed with the arguments that were popped from the operand stack.
The exact mechanism used to invoke native methods is implementation-specific.

When the method called by invokeinterface returns, any single (or
double) word return result is placed on the operand stack of the current
method. If the invoked method was marked as synchronized, the monitor
associated with <i>objectref</i> is exited. Then execution continues at the
instruction that follows invokeinterface in the bytecode.</desc>
<exceptions>NullPointerException - <i>objectref</i> is null

StackOverflowError - no more space in callstack for a new stack frame</exceptions>
<bytecode><table>
<tr>
<td>
<b> Type </b>
</td>
<td><b>Description</b></td></tr>
<tr>
<td>
u1 
</td>
<td>invokeinterface
opcode = 0xB9 (185)
</td></tr>
<tr>
<td>
u2 
</td>
<td><i>index</i></td></tr>
<tr>
<td>
u1 
</td>
<td>&lt;n&gt;</td></tr>
<tr>
<td>
u1 
</td>
<td>0</td></tr>
</table></bytecode>
<see>invokevirtual, invokespecial, invokestatic</see>
<note>1. Of the instructions used to invoke instance methods,
invokeinterface is the most complex to implement, and typically the
least efficient. See Chapter 10 (Implementation) for more details on this.


2. invokevirtual cannot be used to invoke the special methods
&lt;init&gt; or &lt;clinit&gt; - see
invokespecial.

3. The &lt;n&gt; and 0 byte parameters in bytecode are present mostly for
historical reasons.</note>
</opcode>
<opcode>
<name>invokespecial</name>
<short>invoke method belonging to a specific class</short>
<stack><table>
<tr>
<td>
<b>Before </b>
</td>
<td><b>After</b></td></tr>
<tr>
<td>argN</td>
<td>[result]</td></tr>
<tr>
<td>---</td>
<td>...</td></tr>
<tr>
<td>arg2</td>
<td>...</td></tr>
<tr>
<td>arg1</td>
<td>...</td></tr>
<tr>
<td>objectref</td>
<td>...</td></tr>
<tr>
<td>...</td>
<td>...</td></tr>
</table></stack>
<desc>invokespecial is used in certain special cases to invoke a
method Specifically, invokespecial is used to invoke:

the instance initialization method, &lt;init&gt;

a private method of this

a method in a superclass of this

The main use of invokespecial is to invoke an object's instance
initialization method, &lt;init&gt;, during the construction phase for a new
object. For example, when you write in Java:

<pre>
new StringBuffer()
</pre>
code
like the following is generated:

<pre>
new java/lang/StringBuffer         ; create a new StringBuffer
dup                                ; make an extra reference to the new instance
                                   ; now call an instance initialization method
invokespecial java/lang/StringBuffer/&lt;init&gt;()V
                                   ; stack now contains an initialized StringBuffer.
</pre>
invokespecial
is also used by the Java language by the 'super' keyword to access a
superclass's version of a method. For example, in the class:

<pre>
   class Example {
       // override equals
       public boolean equals(Object x) {
            // call Object's version of equals
            return super.equals(x);
       }
   }
</pre>
the
'super.equals(x)' expression is compiled to:

<pre>
aload_0  ; push 'this' onto the stack
aload_1  ; push the first argument (i.e. x) onto the stack
; now invoke Object's equals() method.
invokespecial java/lang/Object/equals(Ljava/lang/Object;)Z
</pre>
Finally,
invokespecial is used to invoke a private method. Remember that private methods
are only visible to other methods belonging the same class as the private
method.   

Before performing the method invokation, the class and the method identified by
&lt;method-spec&gt; are resolved. See Chapter 9 for a description of how
methods are resolved.

invokespecial first looks at the <i>descriptor</i> given in
&lt;method-spec&gt;, and determines how many argument words the method takes
(this may be zero). It pops these arguments off the operand stack. Next it pops
<i>objectref</i> (a reference to an object) off the operand stack.
<i>objectref</i> must be an instance of the class named in &lt;method-spec&gt;,
or one of its subclasses. The interpreter searches the list of methods defined
by the class named in &lt;method-spec&gt;, looking for a method called
<i>methodname</i> whose descriptor is <i>descriptor</i>. This search is not
based on the runtime type of <i>objectref</i>, but on the compile time type
given in &lt;method-spec&gt;.

Once a method has been located, invokespecial calls the method. First,
if the method is marked as synchronized, the monitor associated with
<i>objectref</i> is entered. Next, a new stack frame structure is established
on the call stack. Then the arguments for the method (which were popped off the
current method's operand stack) are placed in local variables of the new stack
frame structure. arg1 is stored in local variable 1, arg2 is stored in local
variable 2 and so on. <i>objectref</i> is stored in local variable 0 (the local
variable used for the special Java variable this). Finally, execution
continues at the first instruction in the bytecode of the new method. 

Methods marked as native are handled slightly differently. For native
methods, the runtime system locates the platform-specific code for the method,
loading it and linking it into the JVM if necessary. Then the native method
code is executed with the arguments popped from the operand stack. The exact
mechanism used to invoke native methods is implementation-specific.

When the method called by invokespecial returns, any single (or
double) word return result is placed on the operand stack of the
current method. If the invoked method was marked as synchronized, the
monitor associated with <i>objectref</i> is exited. Execution continues at the
instruction that follows invokespecial in the bytecode.</desc>
<exceptions>NullPointerException - <i>objectref</i> is null

StackOverflowError - no more space in callstack for a new stack frame</exceptions>
<bytecode><table>
<tr>
<td>
<b> Type </b>
</td>
<td><b>Description</b></td></tr>
<tr>
<td>
u1 
</td>
<td>invokespecial
opcode = 0xB7 (183)
</td></tr>
<tr>
<td>
u2 
</td>
<td>index</td></tr>
</table></bytecode>
<see>invokevirtual, invokeinterface,
invokestatic</see>
<note>1. In Java Virtual Machine implementations prior to version JDK 1.02,
this instruction was called invokenonvirtual, and was less restrictive
than invokespecial - it wasn't limited to invoking only superclass,
private or &lt;init&gt; methods. The class access flag ACC_SUPER (see Chapter
4) is used to indicate which semantics are used by a class. In older class
files, the ACC_SUPER flag is unset. In all new classes, the ACC_SUPER flag
should be set, indicating that the restrictions enforced by
invokespecial are obeyed. (In practice, all the common uses of
invokenonvirtual continue to be supported by invokespecial,
so this change should have little impact on JVM users).</note>
</opcode>
<opcode>
<name>invokestatic</name>
<short>invoke a class (static) method</short>
<stack><table>
<tr>
<td>
<b>Before </b>
</td>
<td><b>After</b></td></tr>
<tr>
<td>argN</td>
<td>[result]</td></tr>
<tr>
<td>...</td>
<td>...</td></tr>
<tr>
<td>arg3</td>
<td>...</td></tr>
<tr>
<td>arg2</td>
<td>...</td></tr>
<tr>
<td>arg1</td>
<td>...</td></tr>
</table></stack>
<desc>invokestatic calls a static method (also known as a class
method). For example, if you write in Java:

<pre>
    System.exit(1);
</pre>
this
is compiled into the JVM code:

<pre>
    iconst_1      ; push 1 onto the stack.
                  ; now call System.exit()
    invokestatic java/lang/System/exit(I)V
</pre>
Before
performing the method invokation, the class and the method identified by
&lt;method-spec&gt; are resolved. See Chapter 9 for a description of how
methods are resolved.

invokestatic looks at the <i>descriptor</i> given in
&lt;method-spec&gt;, and determines how many arguments the method takes (this
may be zero). It pops these arguments off the operand stack. Then it searches
the list of  static methods defined by the class, locating the method
<i>methodname</i> with a descriptor <i>descriptor</i>. 

Once the method has been located, invokestatic calls the method.
First, if the method is marked as synchronized, the monitor associated
with the class object for the method's class is entered. Next, a new stack
frame structure is established on the call stack. Then the arguments for the
method (which were popped off the current method's operand stack) are placed in
local variables of the new stack frame structure. arg1 is stored in local
variable 0, arg2 is stored in local variable 1 and so on. Finally, execution
continues at the first instruction in the bytecode of the new method. 

Methods marked as native are handled slightly differently. For native
methods, the runtime system locates the platform-specific code for the method,
loading it and linking it into the JVM if necessary. Then the native method
code is executed with the arguments that were popped from the operand stack.
The exact mechanism used to invoke native methods is implementation-specific.

When the method called by invokestatic returns, any single (or double)
word return result is placed on the operand stack of the current
method. If the invoked method was marked as synchronized, the monitor
associated with the class named in &lt;method-spec&gt; is exited. Execution
continues at the instruction that follows invokestatic in the
bytecode.</desc>
<exceptions>StackOverflowError - no more space in callstack for a new stack frame</exceptions>
<bytecode><table>
<tr>
<td>
<b> Type </b>
</td>
<td><b>Description</b></td></tr>
<tr>
<td>
u1 
</td>
<td>invokestatic
opcode = 0xB8 (184)
</td></tr>
<tr>
<td>
u2 
</td>
<td>index</td></tr>
</table></bytecode>
<see>invokevirtual, invokespecial,
invokeinterface</see>
</opcode>
<opcode>
<name>invokevirtual</name>
<short>call an instance method</short>
<stack><table>
<tr>
<td>
<b>Before </b>
</td>
<td><b>After</b></td></tr>
<tr>
<td>arg1</td>
<td>[result]</td></tr>
<tr>
<td>arg2</td>
<td>...</td></tr>
<tr>
<td>...</td>
<td>...</td></tr>
<tr>
<td>argN</td>
<td>...</td></tr>
<tr>
<td>objectref</td>
<td>...</td></tr>
<tr>
<td>...</td>
<td>...</td></tr>
</table></stack>
<desc>invokevirtual dispatches a Java method. It is used in Java to
invoke all methods except interface methods (which use
invokeinterface), static methods (which use invokestatic),
and the few special cases handled by invokespecial. 

For example, when you write in Java:

<pre>
    Object x;
    ...
    x.equals("hello");
</pre>
this
is compiled into something like:

<pre>
    aload_1       ; push local variable 1 (i.e. 'x') onto stack
    ldc "hello"   ; push the string "hello" onto stack

    ; invoke the equals method
    invokevirtual java/lang/Object/equals(Ljava/lang/Object;)Z
    ; the boolean result is now on the stack
</pre>
Note
that the actual method run depends on the runtime type of the object
invokevirtual is used with. So in the example above, if x is an
instance of a class that overrides Object's equal method, then the subclasses'
overridden version of the equals method will be used.

Before performing the method invokation, the class and the method identified by
&lt;method-spec&gt; are resolved. See Chapter 9 for a description of how
methods are resolved.

invokevirtual looks at the <i>descriptor</i> given in
&lt;method-spec&gt;, and determines how many arguments the method takes (this
may be zero). It pops these arguments off the operand stack. Next it pops
<i>objectref</i> off the stack. <i>objectref</i> is a reference to the object
whose method is being called. invokevirtual retrieves the Java class
for <i>objectref</i>, and searches the list of methods defined by that class
and then its superclasses, looking for a method called <i>methodname,</i> whose
descriptor is <i>descriptor</i>.

Once a method has been located, invokevirtual calls the method. First,
if the method is marked as synchronized, the monitor associated with
<i>objectref</i> is entered. Next, a new stack frame structure is established
on the call stack. Then the arguments for the method (which were popped off the
current method's operand stack) are placed in local variables of the new stack
frame structure. arg1 is stored in local variable 1, arg2 is stored in local
variable 2 and so on. <i>objectref</i> is stored in local variable 0 (the local
variable used for the special Java variable this). Finally, execution
continues at the first instruction in the bytecode of the new method.  

When the method called by invokevirtual returns, any single (or
double) word return result is placed on the operand stack of the
current method and execution continues at the instruction that follows
invokevirtual in the bytecode.</desc>
<exceptions>NullPointerException - <i>objectref</i> is null

StackOverflowError - no more space in callstack for a new stack frame</exceptions>
<bytecode><table>
<tr>
<td>
<b> Type </b>
</td>
<td><b>Description</b></td></tr>
<tr>
<td>
u1 
</td>
<td>invokevirtual
opcode = 0xB6 (182)
</td></tr>
<tr>
<td>
u2 
</td>
<td>index</td></tr>
</table></bytecode>
<see>invokespecial, invokestatic,
invokeinterface</see>
</opcode>
<opcode>
<name>ireturn</name>
<short>return from method with  integer result</short>
<stack><table>
<tr>
<td>
<b>Before </b>
</td>
<td><b>After</b></td></tr>
<tr>
<td>return-value</td>
<td>n/a</td></tr>
<tr>
<td>...</td>
<td>...</td></tr>
</table></stack>
<desc>Pops an int from the top of the stack and pushes it onto the
operand stack of the invoker (i.e. the method which used
invokevirtual, invokespecial, invokestatic or
invokeinterface to call the currently executing method). All other
items on the current method's operand stack are discarded. If the current
method is marked as synchronized, then an implicit monitorexit instruction is
executed. Then the current method's frame is discarded, the invoker's frame is
reinstated, and control returns to the invoker. This instruction can only be
used in methods whose return type is int.</desc>
<bytecode><table>
<tr>
<td>
<b> Type </b>
</td>
<td><b>Description</b></td></tr>
<tr>
<td>
u1 
</td>
<td>ireturn
opcode = 0xAC (172)
</td></tr>
</table></bytecode>
<see>lreturn, freturn, dreturn, areturn,
return</see>
</opcode>
<opcode>
<name>istore_&lt;n&gt;</name>
<short>store integer in local variable &lt;n&gt;</short>
<stack><table>
<tr>
<td>
<b>Before </b>
</td>
<td><b>After</b></td></tr>
<tr>
<td>value</td>
<td>...</td></tr>
<tr>
<td>...</td>
<td>...</td></tr>
</table></stack>
<desc>Pops an int off the stack and stores it in local variable &lt;n&gt;,
where &lt;n&gt; is 0, 1, 2 or 3. &lt;n&gt; must be a valid local variable
number in the current frame.

'istore_&lt;n&gt;' is functionally equivalent to 'istore
&lt;n&gt;', although it is typically more efficient and also takes fewer
bytes in the bytecode.</desc>
<example><pre>
istore_0        ;store integer in local variable 0
istore_1        ;store integer in local variable 1
istore_2        ;store integer in local variable 2
istore_3        ;store integer in local variable 3
</pre></example>
<bytecode><table>
<tr>
<td>
<b> Type </b>
</td>
<td><b>Description</b></td></tr>
<tr>
<td>
u1 
</td>
<td>istore_0
opcode = 0x3C (59)
</td></tr>
<tr>
<td>
u1 
</td>
<td>istore_1
opcode = 0x3D (60)
</td></tr>
<tr>
<td>
u1 
</td>
<td>istore_2
opcode = 0x3E (61)
</td></tr>
<tr>
<td>
u1 
</td>
<td>istore_3
opcode = 0x3F (62)
</td></tr>
</table></bytecode>
<see>lstore, fstore, dstore, astore</see>
</opcode>
<opcode>
<name>lastore</name>
<short>store in long integer array</short>
<stack><table>
<tr>
<td>
<b>Before </b>
</td>
<td><b>After</b></td></tr>
<tr>
<td>value-word1</td>
<td>...</td></tr>
<tr>
<td>value-word2</td>
<td>...</td></tr>
<tr>
<td>index</td>
<td>...</td></tr>
<tr>
<td>arrayref</td>
<td>...</td></tr>
<tr>
<td>...</td>
<td>...</td></tr>
</table></stack>
<desc>Takes a two-word long integer from the stack and stores it in an array
of long integers. <i>arrayref</i> is a reference to an array of long integers.
<i>index</i> is an int. <i>value</i> is the long integer value to be stored in
the array. <i>arrayref</i>, <i>index</i> and <i>value</i> are removed from the
stack, and <i>value</i> is stored in the array at the given <i>index</i>.</desc>
<exceptions>NullPointerException - <i>arrayref</i> is null

ArrayIndexOutOfBoundsException - <i>index</i> is &lt; 0 or &gt;=
arrayref.length</exceptions>
<bytecode><table>
<tr>
<td>
<b> Type </b>
</td>
<td><b>Description</b></td></tr>
<tr>
<td>
u1 
</td>
<td>lastore
opcode = 0x50 (80)
</td></tr>
</table></bytecode>
<see>iastore, fastore, dastore, aastore,
bastore, castore, sastore, iaload,
laload, faload, daload, aaload,
baload, caload, saload</see>
<note>Array indices start at 0 (the first entry in the array is at
<i>index</i> 0).</note>
</opcode>
<opcode>
<name>lconst_&lt;l&gt;</name>
<short>push the long integer 0 or 1</short>
<stack><table>
<tr>
<td>
<b>Before </b>
</td>
<td><b>After</b></td></tr>
<tr>
<td>...</td>
<td>&lt;l&gt;-word1</td></tr>
<tr>
<td></td>
<td>&lt;l&gt;-word2</td></tr>
<tr>
<td></td>
<td>...</td></tr>
</table></stack>
<desc>lconst_&lt;l&gt; represents the two opcodes lconst_0, lconst_1
that are used to push the constant long integers 0 and 1 onto the stack. For
example, to push the long integer zero onto the stack, use:

<pre>

    lconst_0 ; push long integer 0 onto the stack

</pre>
Note
that you could also use:

<pre>

    ldc2_w 0    ; push the long integer 0 onto the stack

</pre>
although
this instruction takes more space in the class file and is also slower.</desc>
<example><pre>
lconst_0    ; push the long int 0 onto the stack
lconst_1    ; push the long int 1 onto the stack

</pre></example>
<bytecode><table>
<tr>
<td>
<b> Type </b>
</td>
<td><b>Description</b></td></tr>
<tr>
<td>
u1 
</td>
<td>lconst_0
opcode = 0x09 (9)
</td></tr>
<tr>
<td>
u1 
</td>
<td>lconst_1
opcode = 0x0A (10)
</td></tr>
</table></bytecode>
<see>bipush, sipush, ldc, ldc_w,
ldc2_w, aconst_null, iconst_m1
iconst_&lt;n&gt;, fconst_&lt;f&gt;,
dconst_&lt;d&gt;</see>
</opcode>
<opcode>
<name>bastore</name>
<short>store in byte/boolean array</short>
<stack><table>
<tr>
<td>
<b>Before </b>
</td>
<td><b>After</b></td></tr>
<tr>
<td>value</td>
<td>...</td></tr>
<tr>
<td>index</td>
<td>...</td></tr>
<tr>
<td>arrayref</td>
<td>...</td></tr>
<tr>
<td>...</td>
<td>...</td></tr>
</table></stack>
<desc>Takes a 32-bit int from the stack, truncates it to an 8-bit signed byte,
and stores it in an array of bytes. <i>arrayref</i> is a reference to an array
of bytes. <i>index</i> is an int. <i>value</i> is the int value to be stored in
the array. <i>arrayref</i>, <i>index</i> and <i>value</i> are removed from the
stack, and <i>value</i> is truncated to 8 bits and stored in the array at the
given <i>index</i>.

bastore is also used to store values in boolean arrays. In this case,
<i>arrayref</i> is a reference to an array of booleans (see the
newarray instruction) . If value is zero, false is stored at
the given index in the array, otherwise true is stored at the given
index. In Sun's implementation, boolean arrays are actually stored as byte
arrays, using one byte per boolean value. Other implementations might use
packed arrays - or even int arrays - this is invisible to programs running on
the JVM, which always use baload and bastore to access and store values in
boolean arrays.</desc>
<exceptions>NullPointerException - <i>arrayref</i> is null

ArrayIndexOutOfBoundsException - <i>index</i> is &lt; 0 or &gt;=
arrayref.length</exceptions>
<bytecode><table>
<tr>
<td>
<b> Type </b>
</td>
<td><b>Description</b></td></tr>
<tr>
<td>
u1 
</td>
<td>bastore
opcode = 0x54 (84)
</td></tr>
</table></bytecode>
<see>iastore, lastore, fastore, dastore,
aastore, castore, sastore, iaload,
laload, faload, daload, aaload,
baload, caload, saload, newarray,</see>
<note>2. Array indices start at 0 (the first entry in the array is at
<i>index</i> 0).</note>
</opcode>
<opcode>
<name>lload_&lt;n&gt;</name>
<short>retrieve long integer from local variables &lt;n&gt; and
&lt;n&gt; + 1</short>
<stack><table>
<tr>
<td>
<b>Before </b>
</td>
<td><b>After</b></td></tr>
<tr>
<td>...</td>
<td>result-word1</td></tr>
<tr>
<td></td>
<td>result-word2</td></tr>
<tr>
<td></td>
<td>...</td></tr>
</table></stack>
<desc>Retrieves the two-word long integer stored in local variables &lt;n&gt;
and &lt;n&gt; + 1 and pushes it onto the operand stack. Both &lt;n&gt; and
&lt;n&gt; + 1 must be valid local variable numbers in the current frame, and
together they must be holding a long. 

See the description of lload for more information on how longs are
retrieved from local variables.   

'lload_&lt;n&gt;' is functionally equivalent to 'lload
&lt;n&gt;', although it is typically more efficient and also takes fewer bytes
in the bytecode.</desc>
<example><pre>
lload_0         ;push long integer in local variable 0 and 1 onto stack
lload_1         ;push long integer in local variable 1 and 2 onto stack 
lload_2         ;push long integer in local variable 2 and 3 onto stack 
lload_3         ;push long integer in local variable 3 and 4 onto stack 
</pre></example>
<bytecode><table>
<tr>
<td>
<b> Type </b>
</td>
<td><b>Description</b></td></tr>
<tr>
<td>
u1 
</td>
<td>lload_0
opcode = 0x1E (30)
</td></tr>
<tr>
<td>
u1 
</td>
<td>lload_1
opcode = 0x1F (31)
</td></tr>
<tr>
<td>
u1 
</td>
<td>lload_2
opcode = 0x20 (32)
</td></tr>
<tr>
<td>
u1 
</td>
<td>lload_3
opcode = 0x21 (33)
</td></tr>
</table></bytecode>
<see>fload, iload, dload</see>
</opcode>
<opcode>
<name>lookupswitch</name>
<short>match key in table and jump</short>
<stack><table>
<tr>
<td>
<b>Before </b>
</td>
<td><b>After</b></td></tr>
<tr>
<td>item</td>
<td>...</td></tr>
<tr>
<td>...</td>
<td>...</td></tr>
</table></stack>
<desc>This is used to perform an efficient compare-and-jump, as might be
needed for a switch statement. The table used by lookupswitch is given
after the lookupswitch opcode in bytecode.

lookupswitch works as follows. First, an int, <i>item,</i> is taken
from the top of the stack. Then, lookupswitch searches the table looking for an
entry whose &lt;key&gt; field matches <i>item</i>. If a match is found,
execution branches to the address of the corresponding &lt;label&gt;. If no
match is found, execution branches to &lt;labelDefault&gt;.</desc>
<example><pre>
; this is like the Java code:
;      switch (i) {
;           case 1:     return(10);
;           case 10:    return(100);
;           default:    return(0);
;      }
    iload_1    ; push local variable 1 onto the stack (i.e. i)

    ; switch based on the value on the stack
    lookupswitch
        1       : Label1
        10      : Label2
        default : Dlabel
Label1:               ; local variable 1 holds the value 1
    bipush 10    
    ireturn    ; return 10

Label2:               ; local variable 1 holds the value 10
    bipush 100
    ireturn    ; return 100

Dlabel:               ; local variable 1 holds something else 
    bipush 0
    return    ; return 0
</pre></example>
<bytecode><table>
<tr>
<td>
<b> Type </b>
</td>
<td><b>Description</b></td></tr>
<tr>
<td>
u1 
</td>
<td>lookupswitch
opcode = 0xAB (171)
</td></tr>
<tr>
<td>
- 
</td>
<td>...0-3
bytes of padding ...
</td></tr>
<tr>
<td>
s4 
</td>
<td>default_offset</td></tr>
<tr>
<td>
s4 
</td>
<td>n</td></tr>
<tr>
<td>
s4 
</td>
<td>key_1</td></tr>
<tr>
<td>
s4 
</td>
<td>offset_1</td></tr>
<tr>
<td>
s4 
</td>
<td>key_2</td></tr>
<tr>
<td>
s4 
</td>
<td>offset_2</td></tr>
<tr>
<td>
... 
</td>
<td>...</td></tr>
<tr>
<td>
s4 
</td>
<td>key_n</td></tr>
<tr>
<td>
s4 
</td>
<td>offset_n</td></tr>
</table></bytecode>
<see>tableswitch</see>
<note>1. Addresses are measured in bytes from the start of the bytecode (i.e.
address 0 is the first byte in the bytecode of the currently executing
method).

2. Addresses given in the table are relative - the values in the table are
added to the current <i>pc</i> (i.e. the address of this lookupswitch
instruction) to obtain the new value for <i>pc</i>. 

3. Keys in the table must be sorted in increasing order, so &lt;key1&gt; is
less than &lt;key2&gt;, and so on up to &lt;keyN&gt;. Jasmin performs this
sorting automatically.

4. Even though offsets in the table are given as 32-bit ints, the maximum
address in a Java method is limited by other factors to 65535.</note>
</opcode>
<opcode>
<name>lreturn</name>
<short>return from method with long result</short>
<stack><table>
<tr>
<td>
<b>Before </b>
</td>
<td><b>After</b></td></tr>
<tr>
<td>value-word1</td>
<td>n/a</td></tr>
<tr>
<td>value-word2</td>
<td>...</td></tr>
<tr>
<td>...</td>
<td>...</td></tr>
</table></stack>
<desc>Pops a two-word long integer from the top of the stack and
pushes it onto the operand stack of the invoker (i.e. the method which used
invokevirtual, invokespecial, invokestatic or
invokeinterface to call the currently executing method). All other
items on the current method's operand stack are discarded. If the current
method is marked as synchronized, then an implicit monitorexit instruction is
executed. Then the current method's frame is discarded, the invoker's frame is
reinstated, and control returns to the invoker. This instruction can only be
used in methods whose return type is long.</desc>
<bytecode><table>
<tr>
<td>
<b> Type </b>
</td>
<td><b>Description</b></td></tr>
<tr>
<td>
u1 
</td>
<td>lreturn
opcode = 0xAD (173)
</td></tr>
</table></bytecode>
<see>ireturn, freturn, dreturn, areturn,
return</see>
</opcode>
<opcode>
<name>lstore_&lt;n&gt;</name>
<short>store long in local variables &lt;n&gt; and &lt;n&gt; +
1</short>
<stack><table>
<tr>
<td>
<b>Before </b>
</td>
<td><b>After</b></td></tr>
<tr>
<td>value-word1</td>
<td>...</td></tr>
<tr>
<td>value-word2</td>
<td>...</td></tr>
<tr>
<td>...</td>
<td>...</td></tr>
</table></stack>
<desc>Retrieves the long integer stored in local variables &lt;n&gt; and
&lt;n&gt; + 1 and pushes it onto the operand stack. Both &lt;n&gt; and
&lt;n&gt; + 1 must be valid local variable numbers in the current frame, and
together they must be holding a long. 

See the description of lstore for more information on how doubles are
retrieved from local variables.   

'lstore_&lt;n&gt;' is functionally equivalent to 'lstore
&lt;n&gt;', although it is typically more efficient and also takes fewer bytes
in the bytecode.</desc>
<example><pre>
lstore_0        ;store long in local variable 0 and 1
lstore_1        ;store long in local variable 1 and 2
lstore_2        ;store long in local variable 2 and 3
lstore_3        ;store long in local variable 3 and 4
</pre></example>
<bytecode><table>
<tr>
<td>
<b> Type </b>
</td>
<td><b>Description</b></td></tr>
<tr>
<td>
u1 
</td>
<td>lstore_0
opcode = 0x3F (63)
</td></tr>
<tr>
<td>
u1 
</td>
<td>lstore_1
opcode = 0x40 (64)
</td></tr>
<tr>
<td>
u1 
</td>
<td>lstore_2
opcode = 0x41 (65)
</td></tr>
<tr>
<td>
u1 
</td>
<td>lstore_3
opcode = 0x42 (66)
</td></tr>
</table></bytecode>
<see>astore, istore, dstore, fstore</see>
</opcode>
<opcode>
<name>monitorenter</name>
<short>enter synchronized region of code</short>
<stack><table>
<tr>
<td>
<b>Before </b>
</td>
<td><b>After</b></td></tr>
<tr>
<td>objectref</td>
<td>...</td></tr>
<tr>
<td>...</td>
<td>...</td></tr>
</table></stack>
<desc>The monitorenter/monitorexit mechanism is used by the
Java synchronized statement to coordinate access to an object among
multiple threads. For example, when you write in Java code:

<pre>
static void Sort(int [] array) {
    // synchronize this operation so that some other thread can't
    // manipulate the array while we are sorting it. This assumes that other
    // threads also synchronize their accesses to the array.
    synchronized(array) {
        // now sort elements in array
    }
}
</pre>
then
JVM code like the following is generated:

<pre>
.method static Sort([I)V
    aload_0
    monitorenter    ; lock object in local variable 0 

    ; now sort elements in array

    aload_0
    monitorexit      ; finished with object in local variable 0
    return
.end method
</pre>
monitorenter
obtains an exclusive lock on the object referenced by <i>objectref.</i> There
are three possible scenarios:

If no other thread has locked the object, a new lock is established on the
object, and execution continues at the next instruction. 

If the object is currently locked by another thread, monitorenter
blocks, waiting for the other thread to unlock the object. 

If the current thread already owns a lock on the object, a counter is
incremented - the lock will only be released when the counter returns to zero
(see monitorexit).</desc>
<exceptions>NullPointerException - the object reference on the stack is
null.</exceptions>
<bytecode><table>
<tr>
<td>
<b> Type </b>
</td>
<td><b>Description</b></td></tr>
<tr>
<td>
u1 
</td>
<td>monitorenter
opcode = 0xC2 (194)
</td></tr>
</table></bytecode>
<see>monitorexit</see>
<note>1. Methods which are marked as synchronized implicitly perform
a monitorenter when invoked, and a monitorexit when they
return.

2. Java's wait(), notify() and notifyAll() methods also interact with locks on
objects.</note>
</opcode>
<opcode>
<name>monitorexit</name>
<short>leave synchronized region of code</short>
<stack><table>
<tr>
<td>
<b>Before </b>
</td>
<td><b>After</b></td></tr>
<tr>
<td>objectref</td>
<td>...</td></tr>
<tr>
<td>...</td>
<td>...</td></tr>
</table></stack>
<desc>This releases an exclusive lock that was previously obtained using
monitorenter for the object <i>objectref</i>. If other threads are
waiting for the object to become unlocked, one of the waiting threads will be
able to acquire a lock on the object and proceed.

Note that a single thread can lock an object several times - the runtime system
maintains a count of the number of times that the object was locked by the
current thread, and only unlocks the object when the counter reaches zero (i.e.
when the number of monitorenters and monitorexits applied to
a given object are equal). 

The monitorenter/monitorexit mechanism is used by the Java
synchronized statement to coordinate access to an object among
multiple threads.</desc>
<exceptions>NullPointerException - <i>objectref</i> is null. 

IllegalMonitorStateException - <i>objectref</i> was not previously locked by
the current thread.</exceptions>
<bytecode><table>
<tr>
<td>
<b> Type </b>
</td>
<td><b>Description</b></td></tr>
<tr>
<td>u1</td>
<td>monitorexit
opcode = 0xC3 (195)
</td></tr>
</table></bytecode>
<see>monitorenter</see>
</opcode>
<opcode>
<name>multianewarray</name>
<short>allocate multi-dimensional array</short>
<stack><table>
<tr>
<td>
<b>Before </b>
</td>
<td><b>After</b></td></tr>
<tr>
<td>sizeN</td>
<td>arrayref</td></tr>
<tr>
<td>---</td>
<td>...</td></tr>
<tr>
<td>size3</td>
<td>...</td></tr>
<tr>
<td>size2</td>
<td>...</td></tr>
<tr>
<td>size1</td>
<td>...</td></tr>
<tr>
<td>...</td>
<td>...</td></tr>
</table></stack>
<desc>Allocates a multi-dimensional array. In Java, a multi-dimensional array
is structured an array of arrays, i.e. an array whose elements are references
to array objects. So constructing an array like:

<pre>
new int [3][2]
</pre>
produces
a structure in memory like:

    
<A href="ref01.gif">Click here for Picture </A>

   

In this particular example the top level array is an array containing three
32-bit references. Each of these references identifies a two-element int
array.

The same general approach applies to higher dimension arrays. For example, a
three-dimensional array is structured as a top level array of arrayrefs, each
of which refers to an array of arrayrefs, each of which refers to an array of
items.

The lengths of each array within the multi-dimensional array are given as
positive ints on the operand stack. The number of ints taken from the stack is
specified by the unsigned byte parameter &lt;n&gt;. The type of the array is
given as an array type descriptor by the &lt;type&gt; parameter.

The &lt;type&gt; is first resolved to a Java class (see Chapter 7 for a
description of how array type descriptors are resolved).
multianewarray then allocates the first &lt;n&gt; dimensions of a
multidimensional array from the heap. If &lt;n&gt; is one, only the top-level
array is created. So the statement:

<pre>
new int [3][]
</pre>
generates
JVM code like:

<pre>
bipush 3
multianewarray [[I 1    ; construct first dimension of the 2-D array
</pre>
in
this case only the three-element top-level array is created. 

To construct both the top-level array and its sub-arrays, e.g. to fully
construct

<pre>
new int [3][2]
</pre>
use
the JVM code:

<pre>
bipush 3
bipush 2
multianewarray [[I 2    ; construct both dimensions of the 2-D array
</pre>
Here
the second parameter given to multianewarray is 2, so the first and
second dimensions are created (i.e. the top-level array and the array objects
within the top-level array). 

&lt;n&gt; must be less than or equal to the dimensionality given in the array's
descriptor - i.e. it must be less than or equal to the number of '[' characters
at the start of &lt;type&gt;.

The elements within the array are initialized to zero (for numeric and boolean
arrays), or null for arrays of references. multianewarray
leaves a reference to the newly constructed array on the operand stack.</desc>
<example><pre>
; to allocate an array like:
;     new String[2][5]

    bipush 2
    bipush 5
    multianewarray [[Ljava/lang/String; 2   ; construct both dimensions
    ; stack now hold a reference two the new two dimensional array.

;
; multianewarray can be used to allocate only some of the
; dimensions of an array. For example, you write:
;
;     x = new int[6][3][]
;
; using:

    bipush 6
    bipush 3
    multianewarray [[[I 2  ; allocate 2 of the 3 dimensions
    astore_1               ; store array in local variable 1

; then you can create the final dimensions later using
; newarray or anewarray. e.g.
;
;    x[0][1] = new int[50];
;
; would be:

    aload_1         ; push the array
    iconst_0
    aaload          ; get x[0] - an array of arrays of ints

    iconst_1
    bipush 50
    newarray int    ; allocate an array of 50 ints
    aastore         ; store this in x[0][1]

;
; You can also use multianewarray to create
; single-dimensional arrays. e.g.

    bipush 50
    multianewarray [Ljava/lang/Thread; 1

; is the same as writing:

    bipush 50
    anewarray java/lang/Thread

; except that the latter is more efficient.
</pre></example>
<exceptions>NegativeArraySizeException - size is less than zero

OutOfMemoryError - insufficient memory to allocate the array</exceptions>
<bytecode><table>
<tr>
<td>
<b> Type </b>
</td>
<td><b>Description</b></td></tr>
<tr>
<td>
u1 
</td>
<td>multianewarray
opcode = 0xC5 (197)
</td></tr>
<tr>
<td>
u2 
</td>
<td>index</td></tr>
<tr>
<td>
u1 
</td>
<td>&lt;n&gt;</td></tr>
</table></bytecode>
<see>newarray, anewarray, new</see>
<note>You can use multianewarray to allocate single-dimension arrays,
though using anewarray or newarray is more efficient.</note>
</opcode>
<opcode>
<name>breakpoint</name>
<short>reserved opcode</short>
<stack><table>
<tr>
<td>
<b>Before </b>
</td>
<td><b>After</b></td></tr>
<tr>
<td>...</td>
<td>...</td></tr>
</table></stack>
<desc>Opcode 0xCA (202) is a reserved opcode with the mnemonic
breakpoint. This opcode is reserved for internal use by a Java
implementation, and must not appear in any class file - methods containing a
breakpoint will fail verification. 

In Sun's implementation, the breakpoint opcode is used internally as a
place-holder indicating a point in a method where control should pass to the
Java debugger (jdb).</desc>
<bytecode><table>
<tr>
<td>
<b> Type </b>
</td>
<td><b>Description</b></td></tr>
<tr>
<td>
u1 
</td>
<td>breakpoint
opcode = 0xCA (202)
</td></tr>
</table></bytecode>
<see>impdep1, impdep2.</see>
</opcode>
<opcode>
<name>castore</name>
<short>store in character array</short>
<stack><table>
<tr>
<td>
<b>Before </b>
</td>
<td><b>After</b></td></tr>
<tr>
<td>value</td>
<td>...</td></tr>
<tr>
<td>index</td>
<td>...</td></tr>
<tr>
<td>arrayref</td>
<td>...</td></tr>
<tr>
<td>...</td>
<td>...</td></tr>
</table></stack>
<desc>Pops a 32-bit integer from the stack, truncates it to a 16-bit unsigned
value, and stores it in an array of characters. <i>arrayref</i> is a reference
to an array of 16-bit Unicode characters. <i>index</i> is an int. <i>value</i>
is the int value to be stored in the array. <i>arrayref</i>, <i>index</i> and
<i>value</i> are removed from the stack, and <i>value</i> is stored in the
array at the given <i>index</i>.</desc>
<exceptions>NullPointerException - <i>arrayref</i> is null

ArrayIndexOutOfBoundsException - <i>index</i> is &lt; 0 or &gt;=
arrayref.length</exceptions>
<bytecode><table>
<tr>
<td>
<b> Type </b>
</td>
<td><b>Description</b></td></tr>
<tr>
<td>
u1 
</td>
<td>castore
opcode = 0x55 (85)
</td></tr>
</table></bytecode>
<see>iastore, lastore, fastore, dastore,
aastore, bastore, sastore, iaload,
laload, faload, daload, aaload,
baload, caload, saload</see>
<note>Array indices start at 0 (the first entry in the array is at
<i>index</i> 0).</note>
</opcode>
<opcode>
<name>checkcast</name>
<short>ensure type of an object or array</short>
<stack><table>
<tr>
<td>
<b>Before </b>
</td>
<td><b>After</b></td></tr>
<tr>
<td>objectref</td>
<td>objectref</td></tr>
<tr>
<td>...</td>
<td>...</td></tr>
</table></stack>
<desc>checkcast checks that the top item on the operand stack (a
reference to an object or array) can be cast to a given type. For example, if
you write in Java:

<pre>
return ((String)obj);
</pre>
then
the Java compiler will generate something like:

<pre>
aload_1                        ; push -obj- onto the stack
checkcast java/lang/String     ; check its a String
areturn                        ; return it
</pre>
checkcast
is actually a shortand for writing Java code like:

<pre>
if (! (obj == null  ||  obj instanceof &lt;class&gt;)) {
    throw new ClassCastException();
}
// if this point is reached, then object is either null, or an instance of
// &lt;class&gt; or one of its superclasses.
</pre>
In
Jasmin, checkcast takes a single parameter, &lt;type&gt;.
&lt;type&gt; is either the name of a Java class or interface, or it is
the type descriptor of an array. At runtime, the symbolic name given by
&lt;type&gt; is resolved to  a Java class (see Chapter 7 for a description of
how classes are resolved). Next, checkcast examines the top item on
the stack. If objectref belongs to &lt;type&gt; (or one of its
subclasses), or if it is null, the objectref is left on the stack and
execution continues at the subsequent instruction. If not, a
ClassCastException is thrown.</desc>
<example><pre>
; push object in local variable 1 onto stack
aload_1

; check if it is an instance of Throwable or one of its subclasses.
checkcast java/lang/Throwable

; if execution reaches here, the object in local variable 1
; is still on the stack, and is either null or a Throwable object.
</pre>


<pre>
; ---
; Note that checkcast can also be used to check that an array belongs to a given type, 
; e.g. to check that local variable 1 contains an array of Strings, use:

aload_1
checkcast [Ljava/lang/String;

; if execution reaches here, the  object on the stack is an array of Strings, or it is null.
</pre></example>
<exceptions>ClassCastException - the object on the stack is not an instance of the
specified class</exceptions>
<bytecode><table>
<tr>
<td>
<b> Type </b>
</td>
<td><b>Description</b></td></tr>
<tr>
<td>
u1 
</td>
<td>checkcast
opcode = 0xC0 (192)
</td></tr>
<tr>
<td>
u2 
</td>
<td>index</td></tr>
</table></bytecode>
<see>instanceof</see>
</opcode>
<opcode>
<name>dastore</name>
<short>store in double-precision float array</short>
<stack><table>
<tr>
<td>
<b>Before </b>
</td>
<td><b>After</b></td></tr>
<tr>
<td>value-word1</td>
<td>...</td></tr>
<tr>
<td>value-word2</td>
<td>...</td></tr>
<tr>
<td>index</td>
<td>...</td></tr>
<tr>
<td>arrayref</td>
<td>...</td></tr>
<tr>
<td>...</td>
<td>...</td></tr>
</table></stack>
<desc>Pops a two-word double precision floating point number from the stack
and stores it in an array of doubles. <i>arrayref</i> is a reference to an
array of doubles. <i>index</i> is an int. <i>value</i> is the double to be
stored in the array. <i>arrayref</i>, <i>index</i> and <i>value</i> are removed
from the stack, and <i>value</i> is stored in the array at the given
<i>index</i>.</desc>
<exceptions>NullPointerException - <i>arrayref</i> is null

ArrayIndexOutOfBoundsException - <i>index</i> is &lt; 0 or is &gt;=
arrayref.length</exceptions>
<bytecode><table>
<tr>
<td>
<b> Type </b>
</td>
<td><b>Description</b></td></tr>
<tr>
<td>
u1 
</td>
<td>dastore
opcode = 0x52 (82)
</td></tr>
</table></bytecode>
<see>iastore, lastore, fastore, aastore,
bastore, castore, sastore, iaload,
laload, faload, daload, aaload,
baload, caload, saload</see>
<note>Array indices start at 0 (the first entry in the array is at
<i>index</i> 0).</note>
</opcode>
<opcode>
<name>dconst_&lt;d&gt;</name>
<short>push the double 0.0 or 1.0</short>
<stack><table>
<tr>
<td>
<b>Before </b>
</td>
<td><b>After</b></td></tr>
<tr>
<td>...</td>
<td>&lt;d&gt;-word1</td></tr>
<tr>
<td></td>
<td>&lt;d&gt;-word2</td></tr>
<tr>
<td></td>
<td>...</td></tr>
</table></stack>
<desc>dconst_&lt;d&gt; pushes the constant double precision floating
point number &lt;d&gt; onto the stack, where &lt;d&gt; is either 0 or 1. For
example, to push the double precision float 0.0 onto the stack, use:

<pre>

    dconst_0 ; push the double 0.0 onto the stack

</pre>
Note
that you could also use:

<pre>

    ldc2_w 0.0    ; push the double 0.0 onto the stack

</pre>
although
this instruction takes more space in the class file and is typically less
efficient.</desc>
<example><pre>

dconst_0    ; push the double 0.0 onto the stack
dconst_1    ; push the double 1.0 onto the stack

</pre></example>
<bytecode><table>
<tr>
<td>
<b> Type </b>
</td>
<td><b>Description</b></td></tr>
<tr>
<td>
u1 
</td>
<td>dconst_0
opcode = 0x0E (14)
</td></tr>
<tr>
<td>
u1 
</td>
<td>dconst_1
opcode = 0x0F (15)
</td></tr>
</table></bytecode>
<see>bipush, sipush, ldc, ldc_w,
ldc2_w, aconst_null, iconst_m1,
iconst_&lt;n&gt;, lconst_&lt;l&gt;,
fconst_&lt;f&gt;,</see>
</opcode>
<opcode>
<name>aaload</name>
<short>retrieve object reference from array</short>
<stack><table>
<tr>
<td>
<b>Before </b>
</td>
<td><b>After</b></td></tr>
<tr>
<td>index</td>
<td>value</td></tr>
<tr>
<td>arrayref</td>
<td>...</td></tr>
<tr>
<td>...
 
</td>
<td>...</td></tr>
</table></stack>
<desc>Retrieves an object reference from an array of objects and places it on
the stack. <i>arrayref</i> is a reference to an array of objects. <i>index</i>
is an int. The <i>arrayref</i> and <i>index</i> are removed from the stack, and
the object reference at the given <i>index</i> in the array is pushed onto the
stack.</desc>
<example><pre>
; This is like the Java code:
;     Object x = arr[0];
; where x is local variable 2 and arr is an array of objects in local variable 1

aload_1       ; load local variable 1 onto the stack
iconst_0      ; push the integer 0 onto the stack
aaload        ; retrieve the entry
astore_2      ; store the entry in local variable 2
</pre></example>
<exceptions>NullPointerException - <i>arrayref</i> is null 

ArrayIndexOutOfBoundsException - <i>index</i> is &lt; 0 or &gt;=
arrayref.length</exceptions>
<bytecode><table>
<tr>
<td>
<b> Type </b>
</td>
<td><b>Description</b></td></tr>
<tr>
<td>
u1 
</td>
<td>aaload
opcode = 0x32 (50)
</td></tr>
</table></bytecode>
<see>iaload, faload, daload, laload,
baload, caload, saload, iastore,
lastore, fastore, dastore, aastore,
bastore, castore, sastore</see>
<note>Array indices start at 0 (the first entry in the array is at
<i>index</i> 0).</note>
</opcode>
<opcode>
<name>aastore</name>
<short>store object reference in array</short>
<stack><table>
<tr>
<td>
<b>Before </b>
</td>
<td><b>After</b></td></tr>
<tr>
<td>value</td>
<td>...</td></tr>
<tr>
<td>index</td>
<td>...</td></tr>
<tr>
<td>arrayref</td>
<td>...</td></tr>
<tr>
<td>...</td>
<td>...</td></tr>
</table></stack>
<desc>This stores an object reference it in an array of objects.
<i>arrayref</i> is a reference to an array of object references. <i>index</i>
is an int. <i>value</i> is the object reference to be stored in the array.
<i>arrayref</i>, <i>index</i> and <i>value</i> are removed from the stack, and
<i>value</i> is stored in the array at the given <i>index</i>.

The runtime type of <i>value</i> must be assignment-compatible with the type of
the array. For example, if the array is declared as an array of Threads, then
<i>value</i> must either be null or an instance of Thread or one of
its subclasses. An ArrayStoreException is generated if you attempt to store an
incompatible type of object in an array. Assignment compatibility is described
in more detail in Chapter 7.</desc>
<exceptions>ArrayIndexOutOfBoundsException - <i>index</i> is &lt; 0 or &gt;=
arrayref.length

ArrayStoreException - <i>value</i> is not compatible with the type of the
array

NullPointerException - <i>arrayref</i> is null</exceptions>
<bytecode><table>
<tr>
<td>
<b> Type </b>
</td>
<td><b>Description</b></td></tr>
<tr>
<td>
u1 
</td>
<td>aastore
opcode = 0x53 (83)
</td></tr>
</table></bytecode>
<see>iastore, lastore, fastore, dastore,
bastore, castore, sastore, iaload,
laload, faload, daload, aaload,
baload, caload, saload</see>
<note>Array indices start at 0 (the first entry in the array is at
<i>index</i> 0).</note>
</opcode>
<opcode>
<name>aconst_null</name>
<short>push null</short>
<stack><table>
<tr>
<td>
<b>Before</b>
</td>
<td><b>
After</b>
</td></tr>
<tr>
<td>...</td>
<td>null</td></tr>
<tr>
<td></td>
<td>...</td></tr>
</table></stack>
<desc>Pushes the special null object reference onto the stack.
null is a reference to no object, and has no type (null can
be cast to any reference type). null conventionally represents an
invalid or uncreated object. Fields, variables and the elements of object
reference arrays have null as their initial value.</desc>
<bytecode><table>
<tr>
<td>
<b> Type </b>
</td>
<td><b>Description</b></td></tr>
<tr>
<td>
u1 
</td>
<td>aconst_null
opcode = 0x01 (1)
</td></tr>
</table></bytecode>
<see>bipush, sipush, ldc, ldc_w,
ldc2_w, iconst_m1, iconst_&lt;n&gt;,
lconst_&lt;l&gt;, fconst_&lt;f&gt;,
dconst_&lt;d&gt;</see>
</opcode>
<opcode>
<name>aload</name>
<short>retrieve object reference from local variable</short>
<stack><table>
<tr>
<td>
<b>Before</b>
</td>
<td><b>
After</b>
</td></tr>
<tr>
<td>...</td>
<td>objectref</td></tr>
<tr>
<td></td>
<td>...</td></tr>
</table></stack>
<desc>Retrieves an object reference from a local variable and pushes it onto
the operand stack. The aload instruction takes a single parameter,
&lt;varnum&gt;, an unsigned integer which indicates which local variable to
retrieve. The object reference in that local variable is retrieved and placed
on the stack. &lt;varnum&gt; must be a valid local variable number in the
current frame.</desc>
<example><pre>

aload 1         ; push object reference in local variable 1 onto the stack

</pre></example>
<bytecode><table>
<tr>
<td>
<b> Type </b>
</td>
<td><b>Description</b></td></tr>
<tr>
<td>
u1 
</td>
<td>aload
opcode = 0x19 (25)
</td></tr>
<tr>
<td>
u1 
</td>
<td>&lt;varnum&gt;</td></tr>
</table>
There
is also a wide format for this instruction, which supports access to
all local variables from 0 to 65535:
<table>
<tr>
<td>
<b> Type </b>
</td>
<td><b>Description</b></td></tr>
<tr>
<td>u1</td>
<td>wide
opcode = 0xC4 (196)
</td></tr>
<tr>
<td>u1</td>
<td>aload
opcode = 0x19 (25)
</td></tr>
<tr>
<td>u2</td>
<td>&lt;varnum&gt;</td></tr>
</table></bytecode>
<see>fload, iload, lload, dload,
wide</see>
<note>If you use astore to store a returnAddress in a local variable,
you cannot then use aload to retrieve the value of that local
variable. Instead, if a local variable holds a returnAddress, your only choices
are to (1) use ret to return to that address, or (2) use one of the
store instructions to store some other value in the local variable.</note>
</opcode>
<opcode>
<name>aload_&lt;n&gt;</name>
<short>retrieve object reference from local variable &lt;n&gt;</short>
<stack><table>
<tr>
<td>
<b>Before </b>
</td>
<td><b>After</b></td></tr>
<tr>
<td>...</td>
<td>objectref</td></tr>
<tr>
<td></td>
<td>...</td></tr>
</table></stack>
<desc>aload_&lt;n&gt; represents the series of opcodes
aload_0, aload_1, aload_2, and aload_3 that
retrieve an object reference held in local variables 0, 1, 2 or 3 and push it
onto the stack. &lt;n&gt; must be a valid local variable number in the current
frame.

'aload_&lt;n&gt;' is functionally equivalent to 'aload
&lt;n&gt;', although it is typically more efficient and also takes fewer
bytes in the bytecode.</desc>
<example><pre>
aload_0         ;push object in local variable 0
aload_1         ;push object in local variable 1
aload_2         ;push object in local variable 2
aload_3         ;push object in local variable 3
</pre></example>
<bytecode><table>
<tr>
<td>
<b> Type </b>
</td>
<td><b>Description</b></td></tr>
<tr>
<td>
u1 
</td>
<td>aload_0
opcode = 0x2A (42)
</td></tr>
<tr>
<td>
u1 
</td>
<td>aload_1
opcode = 0x2B (43)
</td></tr>
<tr>
<td>
u1 
</td>
<td>aload_2
opcode = 0x2C (44)
</td></tr>
<tr>
<td>
u1 
</td>
<td>aload_3
opcode = 0x2D (45)
</td></tr>
</table></bytecode>
<see>fload, iload, lload, dload</see>
<note>If you use astore to store a returnAddress in a local variable,
you cannot then use aload_&lt;n&gt; to retrieve the value of that
local variable. Instead, if a local variable holds a returnAddress, your only
choices are to (1) use ret to return to that address, or (2) use one
of the store instructions to store some other value in the local variable.</note>
</opcode>
<opcode>
<name>anewarray</name>
<short>allocate new array for objects</short>
<stack><table>
<tr>
<td>
<b>Before </b>
</td>
<td><b>After</b></td></tr>
<tr>
<td>size</td>
<td>arrayref</td></tr>
<tr>
<td>...</td>
<td>...</td></tr>
</table></stack>
<desc>anewarray allocates a new array for holding object references.
It pops an int, <i>size</i>, off the stack and constructs a new array capable
of holding <i>size</i> object references of the type indicated by &lt;type&gt;.


&lt;type&gt; indicates what types of object references are to be stored in the
array (see aastore). It is the name of a class or an interface, or an array
type descriptor. If it is java/lang/Object, for example, then any type
of object reference can be stored in the array. &lt;type&gt; is resolved at
runtime to a Java class, interface or array. See Chapter 7 for a discussion of
how classes are resolved.

A reference to the new array is pushed onto the stack. Entries in the new array
are initially set to null.</desc>
<example><pre>
; Allocate a 10-element array of for holding references to
; Threads. This is like the Java code:
;      Thread x[] = new Thread[10];

bipush 10
anewarray java/lang/Thread
astore_1    ; store the new array in local variable 1

; Allocate a multi-dimensional array like:
;       new String[2][5]

; using anewarray. First, allocate new 2-element array for holding 
; arrays of strings and store it in local variable 1.
iconst_2
anewarray [Ljava/lang/String;      ; type descriptor for array-of-String
astore_1

; next, allocate first array of String[5] and store it in index 0
aload_1
iconst_0
bipush 5
anewarray java/lang/String
aastore

; finally, allocate second array of String[5] and store it in index 1
aload_1
iconst_1
bipush 5
anewarray java/lang/String
aastore

</pre></example>
<exceptions>NegativeArraySizeException - <i>size</i> is less than zero</exceptions>
<bytecode><table>
<tr>
<td>
<b> Type </b>
</td>
<td><b>Description</b></td></tr>
<tr>
<td>
u1 
</td>
<td>anewarray
opcode = 0xBD (189)
</td></tr>
<tr>
<td>
u2 
</td>
<td>index</td></tr>
</table></bytecode>
<see>newarray, multianewarray, new</see>
<note>It is more efficient to use multianewarray to allocate
multi-dimensional arrays.</note>
</opcode>
<opcode>
<name>areturn</name>
<short>return from method with object reference result</short>
<stack><table>
<tr>
<td>
<b>Before </b>
</td>
<td><b>After</b></td></tr>
<tr>
<td>objectref</td>
<td>n/a</td></tr>
<tr>
<td>...</td>
<td>...</td></tr>
</table></stack>
<desc>objectref is a reference to an object. It must be <i>assignment
compatible</i> with the return type of the current method (See Chapter 7 for
details of assignment compatibility). areturn pops objectref off the
stack and pushes it onto the operand stack of the invoker (i.e. the method
which used invokevirtual, invokespecial,
invokestatic or invokeinterface to call the currently
executing method). All other items on the current method's operand stack are
discarded. If the current method is marked as synchronized, then an implicit
monitorexit instruction is executed. Then the current method's frame is
discarded, the invoker's frame is reinstated, and control returns to the
invoker.</desc>
<example><pre>
.class Example
.super java/lang/Object

; This method takes an integer parameter n, and returns a new array of ints of length n.
.method public static makeIntArray(I)[I
    aload_0        ; push the array size (i.e. n) parameter onto the stack
    newarray int   ; make the array
    areturn        ; return the array
.endmethod

    ; an example of calling makeIntArray to make a 10 element array of ints:
    bipush 10
    invokestatic Example/makeIntArray(I)[I
    astore_1 ; store array in local variable 1
</pre></example>
<bytecode><table>
<tr>
<td>
<b> Type </b>
</td>
<td><b>Description</b></td></tr>
<tr>
<td>
u1 
</td>
<td>areturn
opcode = 0xB0 (176)
</td></tr>
</table></bytecode>
<see>lreturn, freturn, dreturn, ireturn,
return, invokevirtual, invokespecial,
invokestatic, invokeinterface</see>
</opcode>
<opcode>
<name>athrow</name>
<short>throw an  exception</short>
<stack><table>
<tr>
<td>
<b>Before </b>
</td>
<td><b>After</b></td></tr>
<tr>
<td>objectref</td>
<td>n/a</td></tr>
<tr>
<td>...</td>
<td>...</td></tr>
</table></stack>
<desc>Removes objectref (a reference to an object) from the operand stack, and
'throws' the exception represented by that object. objectref  is an instance of
Throwable or one of its subclasses. 

To throw an exception, the system searches for a handler for objectref's class
in the exception table of the currently active method. 

If no handler is found, the current method's frame is discarded, its invoker's
frame is reinstated, and the exception is immediately rethrown. This process is
repeated until a handler is found or until there are no more procedures on the
callstack (at which point, the current thread dies, typically printing out an
error message).

If a handler is found, the operand stack of the active method is cleared,
<i>objectref</i> is pushed on the operand stack of the current method, and
execution continues at the first instruction of the handler. 

See Chapter 10 for a full description of exceptions in the JVM.</desc>
<example><pre>
; Throw an IOException. This is equivalent to the Java code:
;
;   throw new java.io.IOException();
;
new java/io/IOException          ; 1) create and initialize an IOException instance
dup                                     
invokespecial java/io/IOException/&lt;init&gt;()V 
athrow                           ; 2) throw the IOException instance on the stack

</pre></example>
<exceptions>NullPointerException - the <i>objectref</i> on the stack is
null.</exceptions>
<bytecode><table>
<tr>
<td>
<b> Type </b>
</td>
<td><b>Description</b></td></tr>
<tr>
<td>
u1 
</td>
<td>athrow
opcode = 0xBF (191)
</td></tr>
</table></bytecode>
</opcode>
<opcode>
<name>caload</name>
<short>retrieve character from array</short>
<stack><table>
<tr>
<td>
<b>Before </b>
</td>
<td><b>After</b></td></tr>
<tr>
<td>index</td>
<td>value</td></tr>
<tr>
<td>arrayref</td>
<td>...</td></tr>
<tr>
<td>...</td>
<td>...</td></tr>
</table></stack>
<desc>Retrieves a character from an array of characters and pushes it on the
operand stack. <i>arrayref</i> is a reference to an array of chars.
<i>index</i> is an int. The <i>arrayref</i> and <i>index</i> are removed from
the stack, and the 16-bit unsigned Unicode character at the given <i>index</i>
in the array is retrieved, zero extended to a 32-bit int, and pushed onto the
stack.</desc>
<example><pre>
; This is like the Java code:
;     char x = arr[0];
; where x is local variable 2 and arr is a
; char array in local variable 1
aload_1       ; load local variable 1 onto the stack
iconst_0      ; push the integer 0 onto the stack
caload        ; retrieve the entry
istore_2      ; store the entry in local variable 2
</pre>
<b>
Exceptions</b>

NullPointerException - <i>arrayref</i> is null

ArrayIndexOutOfBoundsException - <i>index</i> is &lt; 0 or &gt;=
arrayref.length</example>
<bytecode><table>
<tr>
<td>
<b> Type </b>
</td>
<td><b>Description</b></td></tr>
<tr>
<td>
u1 
</td>
<td>caload
opcode = 0x34 (52)
</td></tr>
</table></bytecode>
<see>iaload, laload, faload, daload,
aaload, baload, saload, iastore,
lastore, fastore, dastore, aastore,
bastore, castore, sastore</see>
<note>Array indices start at 0 (the first entry in the array is at
<i>index</i> 0).</note>
</opcode>
<opcode>
<name>dmul</name>
<short>multiply two doubles</short>
<stack><table>
<tr>
<td>
<b>Before </b>
</td>
<td><b>After</b></td></tr>
<tr>
<td>value1-word1</td>
<td>result-word1</td></tr>
<tr>
<td>value1-word2</td>
<td>result-word1</td></tr>
<tr>
<td>value1-word1</td>
<td>...</td></tr>
<tr>
<td>value2-word2</td>
<td>...</td></tr>
<tr>
<td>...</td>
<td>...</td></tr>
</table></stack>
<desc>Pops the top two double-precision floating point numbers off the stack,
multiplies them, and pushes the double-precision result back onto the stack.
Multiplication is performed using the standard IEEE rules for double precision
floating point arithmetic.</desc>
<bytecode><table>
<tr>
<td>
<b> Type </b>
</td>
<td><b>Description</b></td></tr>
<tr>
<td>
u1 
</td>
<td>dmul
opcode = 0x6B (107)
</td></tr>
</table></bytecode>
<see>imul, lmul, fmul</see>
</opcode>
<opcode>
<name>dneg</name>
<short>negate a double</short>
<stack><table>
<tr>
<td>
<b>Before </b>
</td>
<td><b>After</b></td></tr>
<tr>
<td>value-word1</td>
<td>result-word1</td></tr>
<tr>
<td>value-word2</td>
<td>result-word2</td></tr>
<tr>
<td>...</td>
<td>...</td></tr>
</table></stack>
<desc>Removes the top double-precision float from the operand stack, negates
it (i.e. inverts its sign), and pushes the negated result back onto the
stack.

Note that, in IEEE double precision floating point arithmetic, negation is not
quite the same as subtracting from 0.  IEEE has two zeros, +0.0 and -0.0, and
dneg applied to +0.0 is -0.0, whereas (+0.0 minus +0.0) is +0.0.</desc>
<bytecode><table>
<tr>
<td>
<b> Type </b>
</td>
<td><b>Description</b></td></tr>
<tr>
<td>
u1 
</td>
<td>dneg
opcode = 0x77 (119)
</td></tr>
</table></bytecode>
<see>ineg, fneg, lneg</see>
</opcode>
<opcode>
<name>drem</name>
<short>remainder of two doubles</short>
<stack><table>
<tr>
<td>
<b>Before </b>
</td>
<td><b>After</b></td></tr>
<tr>
<td>value1-word1</td>
<td>result-word1</td></tr>
<tr>
<td>value1-word2</td>
<td>result-word2</td></tr>
<tr>
<td>value2-word1</td>
<td>...</td></tr>
<tr>
<td>value2-word2</td>
<td>...</td></tr>
<tr>
<td>...</td>
<td>...</td></tr>
</table></stack>
<desc>Pops two double-precision numbers off the operand stack, divides by the
top double, computes the remainder and pushes the double-precision result back
onto the stack. This is like the C function fmod. The remainder is computed
using the equation:

        remainder = <i>value2</i> - (intof( <i>value2</i> / <i>value1</i> ) *
<i>value1</i>)

where intof () rounds towards the nearest integer, or towards the nearest even
integer if the number is half way between two integers.</desc>
<bytecode><table>
<tr>
<td>
<b> Type </b>
</td>
<td><b>Description</b></td></tr>
<tr>
<td>
u1 
</td>
<td>drem
opcode = 0x73 (115)
</td></tr>
</table></bytecode>
<see>irem, frem, lrem</see>
<note>1. Divide by zero will result in NaN being pushed onto the stack as the
result.

2. This operation is not the same as the IEEE-defined remainder operation,
which uses slightly different rules for rounding. Use the Java library routine
Math.IEEEremainder if you want the IEEE behavior.</note>
</opcode>
<opcode>
<name>dreturn</name>
<short>return from method with double result</short>
<stack><table>
<tr>
<td>
<b>Before </b>
</td>
<td><b>After</b></td></tr>
<tr>
<td>return-value-word1</td>
<td>n/a</td></tr>
<tr>
<td>return-value-word2</td>
<td>...</td></tr>
<tr>
<td>...</td>
<td>...</td></tr>
</table></stack>
<desc>dreturn pops the two-word double off the stack and pushes it
onto the operand stack of the invoker (i.e. the method which used
invokevirtual, invokespecial, invokestatic or
invokeinterface to call the currently executing method). All other
items on the current method's operand stack are discarded. If the current
method is marked as synchronized, then an implicit monitorexit instruction is
executed. Then the current method's frame is discarded, the invoker's frame is
reinstated, and control returns to the invoker. This instruction can only be
used in methods whose return type is double.</desc>
<bytecode><table>
<tr>
<td>
<b> Type </b>
</td>
<td><b>Description</b></td></tr>
<tr>
<td>
u1 
</td>
<td>dreturn
opcode = 0xAF (175)
</td></tr>
</table></bytecode>
<see>areturn, lreturn, freturn, ireturn,
return, invokevirtual, invokespecial,
invokestatic, invokeinterface</see>
</opcode>
<opcode>
<name>fload_&lt;n&gt;</name>
<short>retrieve float  from local variable &lt;n&gt;</short>
<stack><table>
<tr>
<td>
<b>Before </b>
</td>
<td><b>After</b></td></tr>
<tr>
<td>...</td>
<td>float-value</td></tr>
<tr>
<td></td>
<td>...</td></tr>
</table></stack>
<desc>fload_&lt;n&gt; represents the series of opcodes
fload_0, fload_1, fload_2, and fload_3 that
retrieve a single precision float in local variables 0, 1, 2 or 3 and push it
onto the stack. &lt;n&gt; must be a valid local variable number in the current
frame.

'fload_&lt;n&gt;' is functionally equivalent to 'fload
&lt;n&gt;', although it is typically more efficient and also takes fewer
bytes in the bytecode.</desc>
<example><pre>
fload_0         ;push float in local variable 0
fload_1         ;push float in local variable 1
fload_2         ;push float in local variable 2
fload_3         ;push float in local variable 3

</pre></example>
<bytecode><table>
<tr>
<td>
<b> Type </b>
</td>
<td><b>Description</b></td></tr>
<tr>
<td>
u1 
</td>
<td>fload_0
opcode = 0x22 (34)
</td></tr>
<tr>
<td>
u1 
</td>
<td>fload_1
opcode = 0x23 (35)
</td></tr>
<tr>
<td>
u1 
</td>
<td>fload_2
opcode = 0x24 (36)
</td></tr>
<tr>
<td>
u1 
</td>
<td>fload_3
opcode = 0x25 (37)
</td></tr>
</table></bytecode>
<see>aload, iload, lload, dload,
fload</see>
</opcode>
<opcode>
<name>fmul</name>
<short>multiply two floats</short>
<stack><table>
<tr>
<td>
<b>Before </b>
</td>
<td><b>After</b></td></tr>
<tr>
<td>value1</td>
<td>result</td></tr>
<tr>
<td>value2</td>
<td>...</td></tr>
<tr>
<td>...</td>
<td>...</td></tr>
</table></stack>
<desc>Pops two single-precision floating point numbers off of the stack,
multiplies them, and pushes the single precision result back onto the stack.
IEEE 754 rules for floating point arithmetic are used.</desc>
<bytecode><table>
<tr>
<td>
<b> Type </b>
</td>
<td><b>Description</b></td></tr>
<tr>
<td>
u1 
</td>
<td>fmul
opcode = 0x6A (106)
</td></tr>
</table></bytecode>
<see>imul, lmul, dmul</see>
</opcode>
<opcode>
<name>ifgt</name>
<short>jump if greater than zero</short>
<stack><table>
<tr>
<td>
<b>Before </b>
</td>
<td><b>After</b></td></tr>
<tr>
<td>value</td>
<td>...</td></tr>
<tr>
<td>...</td>
<td>...</td></tr>
</table></stack>
<desc>ifgt pops the top int off the operand stack. If the int is
greater than zero, execution branches to the address (<i>pc</i> +
<i>branchoffset</i>), where <i>pc</i> is the address of the ifgt
opcode in the bytecode and <i>branchoffset</i> is a 16-bit signed integer
parameter following the ifgt opcode in the bytecode. If the int on the
stack does is less than or equal to zero, execution continues at the next
instruction.

If you are using Jasmin, <i>branchoffset</i> is computed for you from the
address of &lt;label&gt;.</desc>
<example><pre>
    iload_1         ; push the int value in local variable 1 onto the stack
    ifgt Label      ; if the value on the stack is greater than zero, jump to Label
    return          ; return if local variable 1 is less than or equal to zero
Label:
    ; execution continues here if local variable 1 is greater than zero...
</pre></example>
<bytecode><table>
<tr>
<td>
<b> Type </b>
</td>
<td><b>Description</b></td></tr>
<tr>
<td>
u1 
</td>
<td>ifgt
opcode = 0x9D (157)
</td></tr>
<tr>
<td>
s2 
</td>
<td><i>branchoffset</i></td></tr>
</table></bytecode>
<see>ifnull, ifeq, ifle, ifne,
ifnonnull, iflt, ifge</see>
<note>Addresses are measured in bytes from the start of the bytecode (i.e.
address 0 is the first byte in the bytecode of the currently executing
method).</note>
</opcode>
<opcode>
<name>ifle</name>
<short>jump if less than or equal to zero</short>
<stack><table>
<tr>
<td>
<b>Before </b>
</td>
<td><b>After</b></td></tr>
<tr>
<td>value</td>
<td>...</td></tr>
<tr>
<td>...</td>
<td>...</td></tr>
</table></stack>
<desc>ifle pops the top int off the operand stack. If the int is less
than or equal to zero, execution branches to the address (<i>pc</i> +
<i>branchoffset</i>), where <i>pc</i> is the address of the ifle
opcode in the bytecode and <i>branchoffset</i> is a 16-bit signed integer
parameter following the ifle opcode in the bytecode. If the int on the
stack is greater than  zero, execution continues at the next instruction.

If you are using Jasmin, <i>branchoffset</i> is computed for you from the
address of &lt;label&gt;.</desc>
<example><pre>
    iload_1         ; push the int value in local variable 1 onto the stack
    ifle Label      ; if the value on the stack is &lt;= zero, jump to Label
    return          ; return if local variable 1 is greater than zero
Label:
    ; execution continues here if local variable 1 is less than or equal to zero...
</pre></example>
<bytecode><table>
<tr>
<td>
<b> Type </b>
</td>
<td><b>Description</b></td></tr>
<tr>
<td>
u1 
</td>
<td>ifle
opcode = 0x9E (158)
</td></tr>
<tr>
<td>
s2 
</td>
<td><i>branchoffset</i></td></tr>
</table></bytecode>
<see>ifnull, ifeq, iflt, ifne,
ifnonnull, ifgt, ifge</see>
<note>Addresses are measured in bytes from the start of the bytecode (i.e.
address 0 is the first byte in the bytecode of the currently executing
method).</note>
</opcode>
<opcode>
<name>iflt</name>
<short>jump if less than zero</short>
<stack><table>
<tr>
<td>
<b>Before </b>
</td>
<td><b>After</b></td></tr>
<tr>
<td>value</td>
<td>...</td></tr>
<tr>
<td>...</td>
<td>...</td></tr>
</table></stack>
<desc>iflt pops the top int off the operand stack. If the int is less
than zero, execution branches to the address (<i>pc</i> + <i>branchoffset</i>),
where <i>pc</i> is the address of the iflt opcode in the bytecode and
<i>branchoffset</i> is a 16-bit signed integer parameter following the
ifeq opcode in the bytecode. If the int on the stack is greater than
or equal to zero, execution continues at the next instruction.

If you are using Jasmin, <i>branchoffset</i> is computed for you from the
address of &lt;label&gt;.</desc>
<example><pre>
    iload_1         ; push the int value in local variable 1 onto the stack
    iflt Label      ; if the value on the stack is below zero, jump to Label
    return          ; return if local variable 1 is greater than or equal to zero
Label:
    ; execution continues here if local variable 1 is less than zero...
</pre></example>
<bytecode><table>
<tr>
<td>
<b> Type </b>
</td>
<td><b>Description</b></td></tr>
<tr>
<td>
u1 
</td>
<td>iflt
opcode = 0x9B (155)
</td></tr>
<tr>
<td>
s2 
</td>
<td><i>branchoffset</i></td></tr>
</table></bytecode>
<see>ifnull, ifeq, ifle, ifne,
ifnonnull, ifgt, ifge</see>
<note>Addresses are measured in bytes from the start of the bytecode (i.e.
address 0 is the first byte in the bytecode of the currently executing
method).</note>
</opcode>
<opcode>
<name>ifne</name>
<short>jump if nonzero</short>
<stack><table>
<tr>
<td>
<b>Before </b>
</td>
<td><b>After</b></td></tr>
<tr>
<td>value</td>
<td>...</td></tr>
<tr>
<td>...</td>
<td>...</td></tr>
</table></stack>
<desc>ifne pops the top int off the operand stack. If the int does
not equal zero, execution branches to the address (<i>pc</i> +
<i>branchoffset</i>), where <i>pc</i> is the address of the ifne
opcode in the bytecode and <i>branchoffset</i> is a 16-bit signed integer
parameter following the ifne opcode in the bytecode. If the int on the
stack equals zero, execution continues at the next instruction.

If you are using Jasmin, <i>branchoffset</i> is computed for you from the
address of &lt;label&gt;.</desc>
<example><pre>
    iload_1         ; push the int value in local variable 1 onto the stack
    ifne Label      ; if the value on the stack is nonzero, jump to Label
    return          ; return if local variable 1 is zero
Label:
    ; execution continues here if local variable 1 does not equal zero...
</pre></example>
<bytecode><table>
<tr>
<td>
<b> Type </b>
</td>
<td><b>Description</b></td></tr>
<tr>
<td>
u1 
</td>
<td>ifne
opcode = 0x9A (154)
</td></tr>
<tr>
<td>
s2 
</td>
<td><i>branchoffset</i></td></tr>
</table></bytecode>
<see>ifnull, ifeq, ifle, iflt,
ifnonnull, ifgt, ifge</see>
<note>Addresses are measured in bytes from the start of the bytecode (i.e.
address 0 is the first byte in the bytecode of the currently executing
method).</note>
</opcode>
<opcode>
<name>ifnonnull</name>
<short>jump if non-null</short>
<stack><table>
<tr>
<td>
<b>Before </b>
</td>
<td><b>After</b></td></tr>
<tr>
<td>objectref</td>
<td>...</td></tr>
<tr>
<td>...</td>
<td>...</td></tr>
</table></stack>
<desc>ifnonnull pops the top object reference off the operand stack.
If the object reference is not the special null reference, execution
branches to the address (<i>pc</i> + <i>branchoffset</i>), where <i>pc</i> is
the address of the ifnonnull opcode in the bytecode and
<i>branchoffset</i> is a 16-bit signed integer parameter following the
ifnonnull opcode in the bytecode. If the object reference on the stack
is null, execution continues at the next instruction.

If you are using Jasmin, <i>branchoffset</i> is computed for you from the
address of &lt;label&gt;.</desc>
<example><pre>
    aload_1         ; push the object reference in local variable 1 onto the stack
    ifnonnull Label ; if local variable isn't null, jump to Label
    return          ; return if local variable 1 is null
Label:
    ; execution continues here if local variable 1 is something other than null ...
</pre></example>
<bytecode><table>
<tr>
<td>
<b> Type </b>
</td>
<td><b>Description</b></td></tr>
<tr>
<td>
u1 
</td>
<td>ifnonnull
opcode = 0xC7 (199)
</td></tr>
<tr>
<td>
s2 
</td>
<td><i>branchoffset</i></td></tr>
</table></bytecode>
<see>ifnull, ifeq, ifle, iflt,
ifne, ifgt, ifge</see>
<note>Addresses are measured in bytes from the start of the bytecode (i.e.
address 0 is the first byte in the bytecode of the currently executing
method).</note>
</opcode>
<opcode>
<name>ifnull</name>
<short>jump if null</short>
<stack><table>
<tr>
<td>
<b>Before </b>
</td>
<td><b>After</b></td></tr>
<tr>
<td>objectref</td>
<td>...</td></tr>
<tr>
<td>...</td>
<td>...</td></tr>
</table></stack>
<desc>ifnull pops the top object reference off the operand stack. If
the object reference is to the special object null, execution branches
to the address (<i>pc</i> + <i>branchoffset</i>), where <i>pc</i> is the
address of the ifnull opcode in the bytecode and <i>branchoffset</i>
is a 16-bit signed integer parameter following the ifnull opcode in
the bytecode. If the object reference on the stack is not null,
execution continues at the next instruction.

If you are using Jasmin, <i>branchoffset</i> is computed for you from the
address of &lt;label&gt;.</desc>
<example><pre>
    aload_1         ; push the object reference in local variable 1 onto the stack
    ifnull Label    ; if local variable 1 is null, jump to Label
    return          ; return if local variable 1 isn't null
Label:
    ; execution continues here if local variable 1 is null...
</pre></example>
<bytecode><table>
<tr>
<td>
<b> Type </b>
</td>
<td><b>Description</b></td></tr>
<tr>
<td>
u1 
</td>
<td>ifnull
opcode = 0xC6 (198)
</td></tr>
<tr>
<td>
s2 
</td>
<td>branch-offset</td></tr>
</table></bytecode>
<see>ifeq, iflt, ifle, ifne,
ifnonnull, ifgt, ifge</see>
<note>Addresses are measured in bytes from the start of the bytecode (i.e.
address 0 is the first byte in the bytecode of the currently executing
method).</note>
</opcode>
<opcode>
<name>iinc</name>
<short>increment integer in local variable</short>
<stack><table>
<tr>
<td>
<b>Before </b>
</td>
<td><b>After</b></td></tr>
<tr>
<td>...</td>
<td>...</td></tr>
</table></stack>
<desc>iinc increments the int held in the local variable
&lt;varnum&gt; by &lt;n&gt;. The iinc instruction takes two
parameters: &lt;varnum&gt; is an unsigned integer which indicates which local
variable should be used. &lt;n&gt; is the integer amount to increment or
decrement the variable by. &lt;varnum&gt; must be a valid local variable number
in the current method's frame.</desc>
<example><pre>
iinc 1 10       ; increment local variable 1 by 10.
iinc 1 -1       ; decrement local variable 1 by 1.
</pre></example>
<bytecode><table>
<tr>
<td>
<b> Type </b>
</td>
<td><b>Description</b></td></tr>
<tr>
<td>
u1 
</td>
<td>iinc
opcode = 0x84 (132)
</td></tr>
<tr>
<td>
u1 
</td>
<td>&lt;varnum&gt;</td></tr>
<tr>
<td>
s1 
</td>
<td>&lt;n&gt;</td></tr>
</table>
There
is also a wide format for this instruction, which supports access to
all local variables from 0 to 65535, and values of &lt;n&gt; between -32768 and
32767:
<table>
<tr>
<td>
<b> Type </b>
</td>
<td><b>Description</b></td></tr>
<tr>
<td>u1</td>
<td>wide
opcode = 0xC4 (196)
</td></tr>
<tr>
<td>u1</td>
<td>iinc
opcode = 0x84 (132)
</td></tr>
<tr>
<td>u2</td>
<td>&lt;varnum&gt;</td></tr>
<tr>
<td>s2</td>
<td>&lt;n&gt;</td></tr>
</table></bytecode>
<see>wide</see>
</opcode>
<opcode>
<name>iload</name>
<short>retrieve integer from local variable</short>
<stack><table>
<tr>
<td>
<b>Before </b>
</td>
<td><b>After</b></td></tr>
<tr>
<td>...</td>
<td>int-value</td></tr>
<tr>
<td></td>
<td>...</td></tr>
</table></stack>
<desc>Pushes the int value held in a local variable onto the operand stack.
The iload instruction takes a single parameter, &lt;varnum&gt;, an
unsigned integer which indicates which local variable to use. The single-word
int value held in that local variable is retrieved and placed on the stack.
&lt;varnum&gt; must be a valid local variable number in the current method's
frame.</desc>
<example><pre>
bipush 5        ; push 5 onto the stack
istore 1        ; pop 5 off of the stack and store in local variable 1
iload 1         ; push the int in local variable 1 (the value 5)
                ; back onto the stack
</pre></example>
<bytecode><table>
<tr>
<td>
<b> Type </b>
</td>
<td><b>Description</b></td></tr>
<tr>
<td>
u1 
</td>
<td>iload
opcode = 0x15 (21)
</td></tr>
<tr>
<td>
u1
</td>
<td>&lt;varnum&gt;</td></tr>
</table>
There
is also a wide format for this instruction, which supports access to
all local variables from 0 to 65535:
<table>
<tr>
<td>
<b> Type </b>
</td>
<td><b>Description</b></td></tr>
<tr>
<td>u1</td>
<td>wide
opcode = 0xC4 (196)
</td></tr>
<tr>
<td>
u1 
</td>
<td>iload
opcode = 0x15 (21)
</td></tr>
<tr>
<td>
u2 
</td>
<td>&lt;varnum&gt;</td></tr>
</table></bytecode>
<see>aload, fload, lload, dload,
astore, fstore, lstore, dstore,
istore</see>
</opcode>
<opcode>
<name>iload_&lt;n&gt;</name>
<short>push integer from local variable &lt;n&gt;</short>
<stack><table>
<tr>
<td>
<b>Before </b>
</td>
<td><b>After</b></td></tr>
<tr>
<td>...</td>
<td>int-value</td></tr>
<tr>
<td></td>
<td>...</td></tr>
</table></stack>
<desc>iload_&lt;n&gt; represents the series of opcodes
iload_0, iload_1, iload_2, and iload_3 that
retrieve a single precision float in local variables 0, 1, 2 or 3 and push it
onto the stack. &lt;n&gt; must be a valid local variable number in the current
frame.

'iload_&lt;n&gt;' is functionally equivalent to 'iload
&lt;n&gt;', although it is typically more efficient and also takes fewer
bytes in the bytecode.</desc>
<example><pre>
iload_0         ;push integer in local variable 0 onto the stack
iload_1         ;push integer in local variable 1 onto the stack
iload_2         ;push integer in local variable 2 onto the stack
iload_3         ;push integer in local variable 3 onto the stack
</pre></example>
<bytecode><table>
<tr>
<td>
<b> Type </b>
</td>
<td><b>Description</b></td></tr>
<tr>
<td>
u1 
</td>
<td>iload_0
opcode = 0x1A (26)
</td></tr>
<tr>
<td>
u1 
</td>
<td>iload_1
opcode = 0x1B (27)
</td></tr>
<tr>
<td>
u1 
</td>
<td>iload_2
opcode = 0x1C (28)
</td></tr>
<tr>
<td>
u1 
</td>
<td>iload_3
opcode = 0x1D (29)
</td></tr>
</table></bytecode>
<see>iload, fload, lload, dload</see>
</opcode>
<opcode>
<name>impdep1</name>
<short>reserved opcode</short>
<stack><table>
<tr>
<td>
<b>Before </b>
</td>
<td><b>After</b></td></tr>
<tr>
<td>...</td>
<td>...</td></tr>
</table></stack>
<desc>This opcode, like impdep2 and breakpoint, is reserved
for internal use by Java implementations, and must not appear in any class file
- methods containing this opcode will fail verification.</desc>
<bytecode><table>
<tr>
<td>
<b> Type </b>
</td>
<td><b>Description</b></td></tr>
<tr>
<td>
u1 
</td>
<td>imped1
opcode = 0xFE (254)
</td></tr>
</table></bytecode>
<see>impdep2, breakpoint</see>
</opcode>
<opcode>
<name>impdep2</name>
<short>reserved opcode</short>
<stack><table>
<tr>
<td>
<b>Before </b>
</td>
<td><b>After</b></td></tr>
<tr>
<td>...</td>
<td>...</td></tr>
</table></stack>
<desc>This opcode, like impdep1 and breakpoint, is reserved
for internal use by Java implementations, and must not appear in any class file
- methods containing this opcode will fail verification.</desc>
<bytecode><table>
<tr>
<td>
<b> Type </b>
</td>
<td><b>Description</b></td></tr>
<tr>
<td>
u1 
</td>
<td>imped2
opcode = 0xFF (255)
</td></tr>
</table></bytecode>
<see>impdep1, breakpoint</see>
</opcode>
<opcode>
<name>imul</name>
<short>multiply two integers</short>
<stack><table>
<tr>
<td>
<b>Before </b>
</td>
<td><b>After</b></td></tr>
<tr>
<td>value1</td>
<td>result</td></tr>
<tr>
<td>value2</td>
<td>...</td></tr>
<tr>
<td>...</td>
<td>...</td></tr>
</table></stack>
<desc>Pops the top two integers from the operand stack, multiplies them, and
pushes the integer result back onto the stack. On overflow, imul produces a
result whose low order bits are correct, but whose sign bit may be incorrect.</desc>
<bytecode><table>
<tr>
<td>
<b> Type </b>
</td>
<td><b>Description</b></td></tr>
<tr>
<td>
u1 
</td>
<td>imul
opcode = 0x68 (104)
</td></tr>
</table></bytecode>
<see>lmul, fmul, dmul</see>
</opcode>
<opcode>
<name>ldc2_w</name>
<short>push two-word constant onto stack</short>
<stack><table>
<tr>
<td>
<b>Before </b>
</td>
<td><b>After</b></td></tr>
<tr>
<td>...</td>
<td>&lt;value&gt;-word1</td></tr>
<tr>
<td></td>
<td>&lt;value&gt;-word2</td></tr>
<tr>
<td></td>
<td>...</td></tr>
</table></stack>
<desc>ldc2_w pushes a two-word constant value onto the operand stack.
ldc2_w takes a single parameter, <i>&lt;</i>value<i>&gt;</i>, which is
the two-word item to push. The following Java types can be pushed using
ldc2_w:

	long
	double</desc>
<example><pre>
ldc2_w 10             ; push the long integer 10
ldc2_w 1.54           ; push the double precision float 1.54
</pre></example>
<bytecode><table>
<tr>
<td>
<b> Type </b>
</td>
<td><b>Description</b></td></tr>
<tr>
<td>
u1 
</td>
<td>ldc2_w
opcode = 0x14 (20)
</td></tr>
<tr>
<td>
u2 
</td>
<td>index</td></tr>
</table></bytecode>
<see>bipush, sipush, ldc, ldc_w,
aconst_null, iconst_m1, iconst_&lt;n&gt;,
lconst_&lt;l&gt;, fconst_&lt;f&gt;,
dconst_&lt;d&gt;</see>
</opcode>
<opcode>
<name>lload</name>
<short>retrieve long from local variable</short>
<stack><table>
<tr>
<td>
<b>Before </b>
</td>
<td><b>After</b></td></tr>
<tr>
<td>...</td>
<td>result-word1</td></tr>
<tr>
<td></td>
<td>result-word2</td></tr>
<tr>
<td></td>
<td>...</td></tr>
</table></stack>
<desc>lload retrieves a long integer held in a local variable and
pushes it onto the operand stack.

Since long integers are 64-bits wide, and each local variable only
holds up to 32 bits, Java uses two consecutive local variables, &lt;varnum&gt;
and &lt;varnum&gt; + 1  to store a long. So lload &lt;varnum&gt;
actually places the values of both &lt;varnum&gt; and &lt;varnum&gt; + 1 onto
the operand stack. 

Both &lt;varnum&gt; and &lt;varnum&gt; + 1 must be valid local variable numbers
in the current frame, and together they must be holding a long. 

Remember that attempting to treat two-word values as two independent
single-word values will produce a verification error. So trying to retrieve
either &lt;varnum&gt; or &lt;varnum&gt; + 1 independently (e.g. using iload
&lt;varnum&gt;) will produce a verification error. Similarly, if you store
a non-long value in &lt;varnum&gt;, then &lt;varnum&gt; + 1 becomes invalidated
until a new value is stored in it.</desc>
<example><pre>
lconst_1        ; push the long integer 1 onto the stack
lstore 3        ; pop 1 off of the stack and store in local variables 3 and 4
lload 3         ; push the value from local variables 3 and 4 (the long integer 1)
                ; back onto the stack
</pre></example>
<bytecode><table>
<tr>
<td>
<b> Type </b>
</td>
<td><b>Description</b></td></tr>
<tr>
<td>
u1 
</td>
<td>lload
opcode = 0x16 (22)
</td></tr>
<tr>
<td>
u1
</td>
<td>&lt;varnum&gt;</td></tr>
</table>
There
is also a wide format for this instruction, which supports access to
all local variables from 0 to 65535:
<table>
<tr>
<td>
<b> Type </b>
</td>
<td><b>Description</b></td></tr>
<tr>
<td>u1</td>
<td>wide
opcode = 0xC4 (196)
</td></tr>
<tr>
<td>
u1 
</td>
<td>lload
opcode = 0x16 (22)
</td></tr>
<tr>
<td>
u2 
</td>
<td>&lt;varnum&gt;</td></tr>
</table></bytecode>
<see>fload, iload, dload</see>
</opcode>
<opcode>
<name>new</name>
<short>create an object</short>
<stack><table>
<tr>
<td>
<b>Before </b>
</td>
<td><b>After</b></td></tr>
<tr>
<td>...</td>
<td>objectref</td></tr>
<tr>
<td></td>
<td>...</td></tr>
</table></stack>
<desc>new is used to create object instances. 

new takes a single parameter, &lt;class&gt;, the name of the class of
object you want to create. &lt;class&gt; is resolved into a Java class (see
Chapter 7 for a discussion of how classes are resolved).  Then new
determines the size in bytes of instances of  the given class and allocates
memory for the new instance from the garbage collected heap. The fields of the
instance are set to the initial value 0 (for numeric and boolean fields), or
null (for reference fields).  Next, a reference to the new object is
pushed onto the operand stack.

Note that the new object is initialize uninitialized - before the new object
can be used, one of its &lt;init&gt; methods must be called using
invokespecial, as shown in the example below.</desc>
<example><pre>
; This example creates a new StringBuffer object. This is like the Java code:
;
;    StringBuffer x = new StringBuffer();

; 1. use new to create a new object reference
new java/lang/StringBuffer

; 2. dup the object reference and call its constructor
dup
invokespecial java/lang/StringBuffer/&lt;init&gt;()V

; 3. assign object reference on the stack to a local variable
astore_1
; local variable 1 now contains a StringBuffer object,
; ready for use


; the following example shows how to call a non-default
; constructor. It is like the Java code:
;
;    StringBuffer x = new StringBuffer(100);
new java/lang/StringBuffer
dup
bipush 100
invokespecial java/lang/StringBuffer/&lt;init&gt;(I)V
astore_1
</pre></example>
<exceptions>OutOfMemoryError - not enough memory to allocate a new instance

InstantiationError - The class named by &lt;type&gt; is an abstract
class or an interface</exceptions>
<bytecode><table>
<tr>
<td>
<b> Type </b>
</td>
<td><b>Description</b></td></tr>
<tr>
<td>
u1 
</td>
<td>new
opcode = 0xBB (187)
</td></tr>
<tr>
<td>
u2 
</td>
<td>index</td></tr>
</table></bytecode>
<see>anewarray, newarray, multianewarray</see>
</opcode>
<opcode>
<name>newarray</name>
<short>allocate new array for numbers or booleans</short>
<stack><table>
<tr>
<td>
<b>Before </b>
</td>
<td><b>After</b></td></tr>
<tr>
<td>n</td>
<td>arrayref</td></tr>
<tr>
<td>...</td>
<td>...</td></tr>
</table></stack>
<desc>newarray is used to allocate single-dimension arrays of
booleans, chars, floats, doubles, bytes, shorts, ints or longs. For example,
when you write the Java code:

<pre>
new int[10];
</pre>
this
is compiled into:

<pre>
bipush 10          ; push the int 10 onto the stack
newarray int       ; make an array of 10 ints. The new array is left on the stack
</pre>
newarray
pops a positive int, n, off the stack, and constructs an array for holding n
elements of the type given by &lt;type&gt;. Initially the elements in the array
are set to zero. A reference to the new array object is left on the stack.</desc>
<example><pre>
; This is like the Java code:
;     short x[] = new short[2];

iconst_2           ; push 2 onto the stack
newarray short     ; call newarray to make a 2-element short array
astore_1           ; store the reference to the array in local variable 1
</pre></example>
<exceptions>NegativeArraySizeException - n is less than zero.

OutOfMemoryError - insufficient memory to allocate the array.</exceptions>
<bytecode><table>
<tr>
<td>
<b> Type </b>
</td>
<td><b>Description</b></td></tr>
<tr>
<td>
u1 
</td>
<td>newarray
opcode = 0xBC (188)
</td></tr>
<tr>
<td>
u1 
</td>
<td>array-type
(see below)
</td></tr>
</table>


In bytecode, the type of the array is specified by the array-type byte
immediately following the newarray opcode, which has one of the
following values:
<table>
<tr>
<td>
<b>Array Type</b>
</td>
<td><b>Value</b></td></tr>
<tr>
<td>boolean</td>
<td>4</td></tr>
<tr>
<td>char</td>
<td>5</td></tr>
<tr>
<td>float</td>
<td>6</td></tr>
<tr>
<td>double</td>
<td>7</td></tr>
<tr>
<td>byte</td>
<td>8</td></tr>
<tr>
<td>short</td>
<td>9</td></tr>
<tr>
<td>int</td>
<td>10</td></tr>
<tr>
<td>long</td>
<td>11</td></tr>
</table></bytecode>
<see>anewarray, multianewarray, new</see>
<note>The Java boolean <b>false</b> is represented in the JVM by the integer
0; <b>true</b> is represented by the integer 1. Boolean arrays are actually
treated as byte arrays and are initialized to false (0). You should use the
baload and bastore instructions to load and store values in
boolean arrays.</note>
</opcode>
<opcode>
<name>nop</name>
<short>do nothing</short>
<stack><table>
<tr>
<td>
<b>Before </b>
</td>
<td><b>After</b></td></tr>
<tr>
<td>...</td>
<td>...</td></tr>
</table></stack>
<desc>This instruction has no effect - compilers sometimes generate
nop's for debugging, testing or timing purposes.</desc>
<example><pre>
nop             ; do nothing
</pre></example>
<bytecode><table>
<tr>
<td>
<b> Type </b>
</td>
<td><b>Description</b></td></tr>
<tr>
<td>
u1 
</td>
<td>nop
opcode = 0x0 (0)
</td></tr>
</table></bytecode>
</opcode>
<opcode>
<name>pop2</name>
<short>discard top two words on stack</short>
<stack><table>
<tr>
<td>
<b>Before </b>
</td>
<td><b>After</b></td></tr>
<tr>
<td>item1</td>
<td>...</td></tr>
<tr>
<td>item2</td>
<td>...</td></tr>
<tr>
<td>...</td>
<td>...</td></tr>
</table></stack>
<desc>Removes two single-word items from the stack (e.g. two integers, or an
integer and an object reference) or one two-word item (i.e. a double or a
long).</desc>
<example><pre>
invokemethod Myclass/foo()D    ; call double Myclass.foo();
pop2                           ; discard the double result
</pre></example>
<bytecode><table>
<tr>
<td>
<b> Type </b>
</td>
<td><b>Description</b></td></tr>
<tr>
<td>
u1 
</td>
<td>pop2
opcode = 0x58 (88)
</td></tr>
</table></bytecode>
<see>pop</see>
</opcode>
<opcode>
<name>putfield</name>
<short>set value of object field</short>
<stack><table>
<tr>
<td>
<b>Before </b>
</td>
<td><b>After</b></td></tr>
<tr>
<td>value</td>
<td>...</td></tr>
<tr>
<td>objectref</td>
<td>...</td></tr>
<tr>
<td>...</td>
<td>...</td></tr>
</table></stack>
<desc>putfield sets the value of the field identified by
&lt;field-spec&gt; in <i>objectref</i> (a reference to an object) to the single
or double word value on the operand stack. For example, if you have the class:

<pre>
    package xyz;
    class Point {
        public int xCoord, yCoord;
    };
</pre>
Then,
assuming p is an instance of the class Point, writing the Java expression:

<pre>
    p.xCoord = 10;
</pre>
generates
JVM code like:

<pre>
    aload_1                      ; push object in local varable 1 (i.e. p) onto the stack
    bipush 10                    ; push the integer 10 onto the stack
    putfield xyz/Point/xCoord I  ; set the value of the integer field p.xCoord to 10
</pre>
In
Jasmin, putfield takes two parameters, &lt;field-spec&gt; and
&lt;descriptor&gt;. &lt;field-spec&gt; provides <i>classname</i>, the name of
the class that defines the field, as well as <i>fieldname</i>, the name of the
field. In the example above, the &lt;field-spec&gt; is "xyz/Point/xCoord",
indicating that the <i>classname</i> is called "xyz/Point" and the
<i>fieldname</i> is "xCoord". &lt;descriptor&gt; indicates the type of data
held in the field, and is a standard Java type descriptor (see Chapter 4). In
the example above, &lt;descriptor&gt; is "I", since the field holds an
integer.

putfield first resolves <i>classname</i> to a Java class. Then it
locates <i>fieldname</i> in that class, determining the <i>size</i> of the
field (in bytes) and its <i>offset</i> (in bytes) from the base of the object
data. The type of the field must match &lt;descriptor&gt;. See Chapter 7 for a
full discussion of how fields are resolved

To set the value of the field, putfield pops either a 4-byte or 8-byte
quantity off the stack (depending on the field descriptor), and truncates it to
be <i>width</i> bytes long. Then it sets the bytes starting at <i>offset</i>
and extending for <i>width</i> bytes in <i>objectref</i>'s instance data to the
new value.</desc>
<exceptions>NullPointerException - <i>objectref</i> is null</exceptions>
<bytecode><table>
<tr>
<td>
<b> Type </b>
</td>
<td><b>Description</b></td></tr>
<tr>
<td>
u1 
</td>
<td>putfield
opcode = 0xB5 (181)
</td></tr>
<tr>
<td>
u2 
</td>
<td>index</td></tr>
</table></bytecode>
<see>getfield, putstatic, getstatic</see>
<note>Fields cannot be overriden, although they can be 'shadowed'. For
example, with the two classes:

<pre>
    class A { int x; }
and
    class B extends A { int x; }
</pre>
instances
of B will have storage for both the field "A/x" and the field "B/x". Which
field is accessed is determined by the class name given in
&lt;field-spec&gt;.</note>
</opcode>
<opcode>
<name>putstatic</name>
<short>set value of static field</short>
<stack><table>
<tr>
<td>
<b>Before </b>
</td>
<td><b>After</b></td></tr>
<tr>
<td>value</td>
<td>...</td></tr>
<tr>
<td>...</td>
<td>...</td></tr>
</table></stack>
<desc>putstatic sets the value of the static field (also known as a
class field) identified by &lt;field-spec&gt; to the single or double word
value on the operand stack. For example, when you write the Java expression:

<pre>
    java.lang.System.out = myStream;
</pre>
this
generates a call to getstatic like:

<pre>
    aload_1    ; push object reference in local variable 1 (i.e. myStream) onto stack
               ; now use putstatic to assign it to System.out
    putstatic java/lang/System/out Ljava/io/PrintStream;
</pre>
In
Jasmin, putstatic takes two parameters, &lt;field-spec&gt; and
&lt;descriptor&gt;. &lt;field-spec&gt; provides <i>classname</i>, the name of
the class that defines the static field, as well <i>fieldname</i>, as the name
of the field. In the example above, the &lt;field-spec&gt; is
"java/lang/System/out", indicating that the <i>classname</i> is
"java/lang/System" and the <i>fieldname</i> is "out".  &lt;descriptor&gt;
indicates the type of data held in the field, and is a standard Java type
descriptor (see Chapter 4). In the example above, &lt;descriptor&gt; is
"Ljava/io/PrintStream;", i.e. an instance of the PrintStream class.

putstatic first resolves <i>classname</i> into a Java class. Then it
locates the <i>fieldname</i> in that class, determining the <i>width</i> of the
field (in bytes) and its <i>offset</i> (in bytes) from the base of the class's
static data. The type of the field must match &lt;descriptor&gt;. See Chapter 7
for more on how fields are resolved

To set the value of the field, putstatic pops either a 4-byte or
8-byte quantity off the stack (depending on the field descriptor), and
truncates it to be <i>wodth</i> bytes long. Then it sets the bytes starting at
<i>offset</i> and extending for <i>width</i> bytes in the class's static data
to the new value.</desc>
<bytecode><table>
<tr>
<td>
<b> Type </b>
</td>
<td><b>Description</b></td></tr>
<tr>
<td>
u1 
</td>
<td>putstatic
opcode = 0xB3 (179)
</td></tr>
<tr>
<td>
u2 
</td>
<td>index</td></tr>
</table></bytecode>
<see>putfield, getfield, getstatic</see>
<note>Fields cannot be overriden, although they can be 'shadowed'. For
example, with the two classes:

<pre>
    class A { static int X; }
and
    class B extends A { static int X; }
</pre>
then
the runtime system will allocate storage for both the static field "A/X" and
the static field "B/X". Which field is accessed is determined by the class name
given in &lt;field-spec&gt;.</note>
</opcode>
<opcode>
<name>ret</name>
<short>return from subroutine</short>
<stack><table>
<tr>
<td>
<b>Before </b>
</td>
<td><b>After</b></td></tr>
<tr>
<td>...</td>
<td>...</td></tr>
</table></stack>
<desc>ret is used to return from a subroutine that was invoked by
jsr or jsr_w. It takes a single parameter,
&lt;varnum&gt;, an unsigned integer which local variable is holding
the returnAddress for this subroutine. Execution continues at the address
stored in that local variable.

Return addresses are left on the stack by the jsr and jsr_w
instructions. Methods are expected to immediately store the return address in a
local variable, ready for use with ret.</desc>
<example><pre>
; This example method uses a PrintMe subroutine to invoke the System.out.println() method.

.method usingSubroutine()V
    ldc "Message 1"
    jsr PrintMe          ; print "Message 1"

    ldc "Message 2"
    jsr PrintMe          ; print "Message 2"

    ldc "Message 3"
    jsr PrintMe          ; print "Message 3"

    return   ; now return from usingSubroutine

; define the PrintMe subroutine ...
PrintMe:       
    astore_1            ; store return-address in local variable 1
    ; call System.out.println()
    getstatic java/lang/System/out Ljava/io/PrintStream;
    invokevirtual java/io/PrintStream/println(Ljava/lang/String;)V

    ret 1               ; return to the return-address in local variable 1
.end method

</pre></example>
<bytecode><table>
<tr>
<td>
<b> Type </b>
</td>
<td><b>Description</b></td></tr>
<tr>
<td>
u1 
</td>
<td>ret
opcode = 0xA9 (169)
</td></tr>
<tr>
<td>
u1 
</td>
<td>&lt;varnum&gt;</td></tr>
</table>
There
is also a wide format for this instruction, which supports access to
all local variables from 0 to 65535:
<table>
<tr>
<td>
<b> Type </b>
</td>
<td><b>Description</b></td></tr>
<tr>
<td>u1</td>
<td>wide
opcode = 0xC4 (196)
</td></tr>
<tr>
<td>
u1 
</td>
<td>ret
opcode = 0xA9 (169)
</td></tr>
<tr>
<td>
u2 
</td>
<td>&lt;varnum&gt;</td></tr>
</table></bytecode>
<see>jsr, jsr_w, goto, goto_w,
wide</see>
<note>The assymetry between jsr (which pushes a returnAddress onto
the stack) and ret (which gets the returnAddress from a local
variable) is intentional - the bytecode verifier relies on this structure (see
Chapter 5) .</note>
</opcode>
<opcode>
<name>return</name>
<short>return from method</short>
<stack><table>
<tr>
<td>
<b>Before </b>
</td>
<td><b>After</b></td></tr>
<tr>
<td>...</td>
<td>...</td></tr>
</table></stack>
<desc>return is used to return from a method whose return type is
void.

All items on the current method's operand stack are discarded. If the current
method is marked as synchronized, then an implicit monitorexit instruction is
executed. Then the current method's frame is discarded, the invoker's frame is
reinstated, and control returns to the invoker.</desc>
<example><pre>
; the following method takes no parameters, performs no actions, and returns no results.
.method identity()V
    return  ; simply return with no result
.end method

</pre></example>
<bytecode><table>
<tr>
<td>
<b> Type </b>
</td>
<td><b>Description</b></td></tr>
<tr>
<td>
u1 
</td>
<td>return
opcode = 0xB1 (177)
</td></tr>
</table></bytecode>
<see>lreturn, freturn, dreturn, areturn,
ireturn</see>
</opcode>
<opcode>
<name>saload</name>
<short>retrieve short from array</short>
<stack><table>
<tr>
<td>
<b>Before </b>
</td>
<td><b>After</b></td></tr>
<tr>
<td>index</td>
<td>value</td></tr>
<tr>
<td>arrayref</td>
<td>...</td></tr>
<tr>
<td>...</td>
<td>...</td></tr>
</table></stack>
<desc>Retrieves a short from an array of shorts and places it on the stack.
<i>arrayref</i> is a reference to an array of shorts. <i>index</i> is an int.
The <i>arrayref</i> and <i>index</i> are removed from the stack, and the 16-bit
signed short at the given <i>index</i> in the array is retrieved, sign-extended
to an int, and pushed onto the stack.</desc>
<example><pre>
; This is like the Java code:
;      short x = arr[0];
; where x is local variable 2 and arr is
; an array in local variable 1
aload_1       ; load local variable 1 onto the stack
iconst_0      ; push the integer 0 onto the stack
saload        ; retrieve the entry
istore_2      ; store the entry in local variable 2
</pre>
<b>
Exceptions</b>

NullPointerException - <i>arrayref</i> is null

ArrayIndexOutOfBoundsException - <i>index</i> is &lt; 0 or &gt;=
arrayref.length</example>
<bytecode><table>
<tr>
<td>
<b> Type </b>
</td>
<td><b>Description</b></td></tr>
<tr>
<td>
u1 
</td>
<td>saload
opcode = 0x35 (53)
</td></tr>
</table></bytecode>
<see>iaload, laload, faload, daload,
aaload, baload, caload, iastore,
lastore, fastore, dastore, aastore,
bastore, castore, sastore</see>
<note>Array indices start at 0 (the first entry in the array is at
<i>index</i> 0).</note>
</opcode>
<opcode>
<name>sastore</name>
<short>store in short array</short>
<stack><table>
<tr>
<td>
<b>Before </b>
</td>
<td><b>After</b></td></tr>
<tr>
<td>value</td>
<td>...</td></tr>
<tr>
<td>index</td>
<td>...</td></tr>
<tr>
<td>arrayref</td>
<td>...</td></tr>
<tr>
<td>...</td>
<td>...</td></tr>
</table></stack>
<desc>Takes an int from the stack, truncates it to a signed 16-bit short, and
stores it in an array of shorts. <i>arrayref</i> is a reference to an array of
16-bit signed shorts. <i>index</i> is an int. <i>value</i> is the int to be
stored in the array. <i>arrayref</i>, <i>index</i> and <i>value</i> are removed
from the stack, and <i>value</i> is stored in the array at the given
<i>index</i>.</desc>
<exceptions>ArrayIndexOutOfBoundsException - <i>index</i> is &lt; 0 or &gt;=
arrayref.length

NullPointerException - <i>arrayref</i> is null</exceptions>
<bytecode><table>
<tr>
<td>
<b> Type </b>
</td>
<td><b>Description</b></td></tr>
<tr>
<td>
u1 
</td>
<td>sastore
opcode = 0x56 (86)
</td></tr>
</table></bytecode>
<see>iastore, lastore, fastore, dastore,
aastore, bastore, castore, iaload,
laload, faload, daload, aaload,
baload, caload, saload</see>
<note>Array indices start at 0 (the first entry in the array is at
<i>index</i> 0).</note>
</opcode>
<opcode>
<name>sipush</name>
<short>push two-byte signed integer</short>
<stack><table>
<tr>
<td>
<b>Before </b>
</td>
<td><b>After</b></td></tr>
<tr>
<td>...</td>
<td>value</td></tr>
<tr>
<td></td>
<td>...</td></tr>
</table></stack>
<desc>sipush takes a single parameter, &lt;n&gt; (a 16-bit signed
integer), sign extends it to a 32-bit int, and pushes the resulting int onto
the operand stack.

sipush is typically  more efficient than ldc. It also
occupies fewer bytes in the class file.</desc>
<example><pre>
sipush    0x10    ; push the value 0x10 (16)
                  ; onto the operand stack
</pre></example>
<bytecode><table>
<tr>
<td>
<b> Type </b>
</td>
<td><b>Description</b></td></tr>
<tr>
<td>
u1 
</td>
<td>sipush
opcode = 0x11 (17)
</td></tr>
<tr>
<td>
s2 
</td>
<td>&lt;n&gt;</td></tr>
</table></bytecode>
<see>bipush, ldc, ldc_w, ldc2_w,
aconst_null, iconst_m1, iconst_&lt;n&gt;,
lconst_&lt;l&gt;, fconst_&lt;f&gt;,
dconst_&lt;d&gt;</see>
</opcode>
<opcode>
<name>swap</name>
<short>swap top two stack words</short>
<stack><table>
<tr>
<td>
<b>Before </b>
</td>
<td><b>After</b></td></tr>
<tr>
<td>word1</td>
<td>word2</td></tr>
<tr>
<td>word2</td>
<td>word1</td></tr>
<tr>
<td>...</td>
<td>...</td></tr>
</table></stack>
<desc>Swaps the top two single-word items on the stack. word1/word2 cannot
belong to a long or double.</desc>
<bytecode><table>
<tr>
<td>
<b> Type </b>
</td>
<td><b>Description</b></td></tr>
<tr>
<td>
u1 
</td>
<td>swap
opcode = 0x5F (95)
</td></tr>
</table></bytecode>
<note>There is no swap2, although you could use:

<pre>
    dup2_x2
    pop2
</pre>
to
achieve the same effect.</note>
</opcode>
<opcode>
<name>tableswitch</name>
<short>jump according to a table</short>
<stack><table>
<tr>
<td>
<b>Before </b>
</td>
<td><b>After</b></td></tr>
<tr>
<td>val</td>
<td>...</td></tr>
<tr>
<td>...</td>
<td>...</td></tr>
</table></stack>
<desc>tableswitch is used to perform computed jump. The jump table
used by tableswitch is given in the bytecode after the
tableswitch opcode.

An integer, <i>val</i>, is popped off the top of the operand stack. If this
value is less than &lt;low&gt;, or if it is greater than &lt;high&gt;,
execution branches to the address (<i>pc</i> + <i>default_offset</i>), where
<i>pc</i> is the address of the tableswitch opcode in the bytecode,
and <i>default_offset</i> is taken from the bytecode and is the relative
address of the instruction at &lt;defaultLabel&gt;.

If val is in the range &lt;low&gt; to &lt;high&gt;, execution branches to the
i'th entry in the table, where i is (<i>val</i> - &lt;low&gt;) and the first
entry in the table is <i>index</i> 0. i.e. <i>pc</i> becomes the address
(<i>pc</i> + table[<i>val</i> - &lt;low&gt;]).

The following pseudo-code illustrates the computation performed by
tableswitch:

<pre>
int val = pop();                // pop an int from the stack
if (val &lt; low || val &gt; high) {  // if its less than &lt;low&gt; or greater than &lt;high&gt;,
    pc += default;              // branch to default 
} else {                        // otherwise
    pc += table[val - low];     // branch to entry in table
}
</pre>
Notice
that all addresses stored in the table are relative to the address of the
tableswitch opcode in the bytecode. If you are using Jasmin, these
addresses are computed for you from the address of  the given labels.</desc>
<example><pre>
    iload_1 ; push local variable 1 onto the stack

    ; if the variable contains 0, jump to ZeroLabel
    ; if the variable contains 1, jump to OneLabel
    ; if the variable contains 2, jump to TwoLabel
    ; otherwis jump to DefaultLabel
    tableswitch 0 2
        ZeroLabel
        OneLabel
        TwoLabel
      default: DefaultLabel

ZeroLabel:
    ; the variable contained 0 ...
    ldc 100
    ireturn   ; return the result 100

OneLabel:
    ; the variable contained 1 ...
    bipush 200
    ireturn   ; return the result 200

TwoLabel:
    ; the variable contained 2 ...
    bipush 300
    ireturn   ; return the result 300

DefaultLabel:
    ; the variable contained something else ...
    bipush 0
    ireturn   ; return the result 0
</pre></example>
<bytecode><table>
<tr>
<td>
<b> Type </b>
</td>
<td><b>Description</b></td></tr>
<tr>
<td>
u1 
</td>
<td>tableswitch
opcode = 0xAA (170)
</td></tr>
<tr>
<td>
- 
</td>
<td>...0-3
bytes of padding ...
</td></tr>
<tr>
<td>
s4 
</td>
<td><i>default_offset</i></td></tr>
<tr>
<td>
s4 
</td>
<td>&lt;low&gt;</td></tr>
<tr>
<td>
s4 
</td>
<td>&lt;low&gt;
+ N - 1
</td></tr>
<tr>
<td>
s4 
</td>
<td>offset_1</td></tr>
<tr>
<td>
s4 
</td>
<td>offset_2</td></tr>
<tr>
<td>
... 
</td>
<td>...</td></tr>
<tr>
<td>
s4 
</td>
<td>offset_N</td></tr>
</table></bytecode>
<see>lookupswitch</see>
<note>Addresses are measured in bytes from the start of the bytecode (i.e.
address 0 is the first byte in the bytecode of the currently executing
method).</note>
</opcode>
<opcode>
<name>wide</name>
<short>next instruction uses 16-bit index</short>
<stack><table>
<tr>
<td>
<b>Before </b>
</td>
<td><b>After</b></td></tr>
<tr>
<td>...</td>
<td>...</td></tr>
</table></stack>
<desc>wide is placed in front of an instruction that accesses a local
variable. You use it to extend the range of local variables available to the
instruction from 8 bits (i.e. 0-255) to 16 bits (i.e. 0-65535). In addition,
for iinc, it increases the increment range. wide is used in
conjunction with one of the following opcodes: aload, dload,
iload, fload, lload, astore,
dstore, istore, fstore, lstore,
iinc and ret. See the reference pages of those instructions
for more details.</desc>
<bytecode><table>
<tr>
<td>
<b> Type </b>
</td>
<td><b>Description</b></td></tr>
<tr>
<td>u1</td>
<td>wide
opcode = 0xC4 (196)
</td></tr>
<tr>
<td>u1</td>
<td>&lt;opcode&gt;</td></tr>
<tr>
<td>u2</td>
<td>&lt;varnum&gt;</td></tr>
</table>
or,
for iinc, use:
<table>
<tr>
<td>
<b> Type </b>
</td>
<td><b>Description</b></td></tr>
<tr>
<td>u1</td>
<td>wide
opcode = 0xC4 (196)
</td></tr>
<tr>
<td>u1</td>
<td>&lt;opcode&gt;</td></tr>
<tr>
<td>u2</td>
<td>&lt;varnum&gt;</td></tr>
<tr>
<td>u2</td>
<td>&lt;n&gt;</td></tr>
</table></bytecode>
<see>aload, iload, fload, dload,
lload, astore, istore, fstore,
dstore, lstore, iinc, ret</see>
<note>The opcode that follows wide cannot be the target of a branch.</note>
</opcode>
<opcode>
<name>astore</name>
<short>store object reference in local variable</short>
<stack><table>
<tr>
<td>
<b>Before </b>
</td>
<td><b>After</b></td></tr>
<tr>
<td>objectref</td>
<td>...</td></tr>
<tr>
<td>...</td>
<td>...</td></tr>
</table></stack>
<desc>Pops <i>objectref</i> (a reference to an object or array) off the stack
and stores it in local variable &lt;varnum&gt;. The astore instruction
takes a single parameter, &lt;varnum&gt;, an unsigned integer which indicates
which local variable is used. &lt;varnum&gt; must be a valid local variable
number in the current frame.</desc>
<example><pre>
aload 1    ; Push object reference in local variable 1 onto stack
astore 3	; and store it in local variable 3
</pre></example>
<bytecode><table>
<tr>
<td>
<b> Type </b>
</td>
<td><b>Description</b></td></tr>
<tr>
<td>
u1 
</td>
<td>astore
opcode = 0x3A (58)
</td></tr>
<tr>
<td>
u1 
</td>
<td>&lt;varnum&gt;</td></tr>
</table>
There
is also a wide format for this instruction, which supports access to
all local variables from 0 to 65535:
<table>
<tr>
<td>
<b> Type </b>
</td>
<td><b>Description</b></td></tr>
<tr>
<td>u1</td>
<td>wide
opcode = 0xC4 (196)
</td></tr>
<tr>
<td>u1</td>
<td>astore
opcode = 0x3A (58)
</td></tr>
<tr>
<td>u2</td>
<td>&lt;varnum&gt;</td></tr>
</table></bytecode>
<see>lstore, istore, dstore, fstore,
wide</see>
<note>astore can also be used to store a returnAddress in a local
variable. See the jsr instruction for more details.</note>
</opcode>
<opcode>
<name>baload</name>
<short>retrieve byte/boolean from array</short>
<stack><table>
<tr>
<td>
<b>Before </b>
</td>
<td><b>After</b></td></tr>
<tr>
<td>index</td>
<td>value</td></tr>
<tr>
<td>arrayref</td>
<td>...</td></tr>
<tr>
<td>...</td>
<td>...</td></tr>
</table></stack>
<desc>Retrieves a byte from a byte array, expands it to an integer and places
it on the operand stack. <i>arrayref</i> is a reference to an array of bytes.
<i>index</i> is an int. The <i>arrayref</i> and <i>index</i> are removed from
the stack, and the 8-bit signed byte at the given <i>index</i> in the array is
retrieved, sign-extended to a 32-bit int, and pushed onto the stack.

baload is also used to retrieve values from boolean arrays. In this case,
<i>arrayref</i> is a reference to an array of booleans (see the
newarray instruction) . If the entry at the given <i>index</i> is
true, then the int 1 is pushed onto the stack, otherwise the int 0 is
pushed onto the stack. In Sun's implementation, boolean arrays are actually
stored as byte arrays, using one byte per boolean value. Other implementations
might use packed arrays - or even int arrays - this is invisible to programs
running on the JVM, which always use baload and bastore to access and store
values in boolean arrays.</desc>
<example><pre>
; This is like the Java code:
;     byte x = arr[0];
; where x is local variable 2 and arr is a byte array in local variable 1
aload_1       ; load local variable 1 onto the stack
iconst_0      ; push the integer 0 onto the stack
baload        ; retrieve the entry
istore_2      ; store the entry in local variable 2
</pre>
<b>
Exceptions</b>

NullPointerException - <i>arrayref</i> is null

ArrayIndexOutOfBoundsException - <i>index</i> is &lt; 0 or &gt;=
arrayref.length</example>
<bytecode><table>
<tr>
<td>
<b> Type </b>
</td>
<td><b>Description</b></td></tr>
<tr>
<td>
u1 
</td>
<td>baload
opcode = 0x33 (51)
</td></tr>
</table></bytecode>
<see>iaload, laload, faload, daload,
aaload, caload, saload, iastore,
lastore, fastore, dastore, aastore,
bastore, castore, sastore, newarray</see>
</opcode>
<opcode>
<name>bipush</name>
<short>push one-byte signed integer</short>
<stack><table>
<tr>
<td>
<b>Before </b>
</td>
<td><b>After</b></td></tr>
<tr>
<td>...</td>
<td>&lt;n&gt;</td></tr>
<tr>
<td>...</td>
<td>...</td></tr>
</table></stack>
<desc>bipush takes a single parameter, &lt;n&gt; (an 8-bit signed
integer), sign extends it to a 32-bit int, and pushes the resulting int value
onto the operand stack.

bipush is typically  more efficient than ldc. It also
occupies fewer bytes in the class file.</desc>
<example><pre>
bipush    0x10    ; push the value 0x10 (16) onto the operand stack
</pre></example>
<bytecode><table>
<tr>
<td>
<b>  Type </b>
</td>
<td><b>Description</b></td></tr>
<tr>
<td>
u1 
</td>
<td>bipush
opcode = 0x10 (16)
</td></tr>
<tr>
<td>
s1 
</td>
<td>&lt;n&gt;</td></tr>
</table></bytecode>
<see>sipush, ldc, ldc_w, ldc2_w,
aconst_null, iconst_m1, iconst_&lt;n&gt;,
lconst_&lt;l&gt;, fconst_&lt;f&gt;,
dconst_&lt;d&gt;</see>
</opcode>
<opcode>
<name>d2f</name>
<short>convert double to float</short>
<stack><table>
<tr>
<td>
<b>Before </b>
</td>
<td><b>After</b></td></tr>
<tr>
<td>double-word1</td>
<td>float-result</td></tr>
<tr>
<td>double-word2</td>
<td>...</td></tr>
<tr>
<td>...</td>
<td>...</td></tr>
</table></stack>
<desc>Pops a two-word double precision floating point number off of the
operand stack, casts it into a single precision float, and pushes the resulting
float back onto the stack. There is a loss of precision and range in the
result.

This conversion is done in accordance with IEEE 754 specifications, with
rounding using IEEE 754 round-to-nearest mode. 

The sign of the value if preserved. A value which is too small to be
represented as a float is converted to positive or negative zero. A value that
is too large to be represented as a float is converted to positive infinity or
negative infinity. If the value was NaN, the result is NaN.</desc>
<bytecode><table>
<tr>
<td>
<b> Type </b>
</td>
<td><b>Description</b></td></tr>
<tr>
<td>
u1 
</td>
<td>d2f
opcode = 0x90 (144)
</td></tr>
</table></bytecode>
<see>d2i, d2l</see>
</opcode>
<opcode>
<name>d2i</name>
<short>convert double to integer</short>
<stack><table>
<tr>
<td>
<b>Before </b>
</td>
<td><b>After</b></td></tr>
<tr>
<td>double-word1</td>
<td>integer-result</td></tr>
<tr>
<td>double-word2</td>
<td>...</td></tr>
<tr>
<td>...</td>
<td>...</td></tr>
</table></stack>
<desc>Pops a two-word double precision floating point number off of the
operand stack, casts it into a 32-bit int, and pushes the resulting int onto
the stack. 

Rounding is done using IEEE 754 round-to-nearest mode. The fractional part is
lost by rounding towards zero, so (int)-3.14 becomes -3. 

If the original double value is NaN, the result is 0. If the value is too large
to be represented as an integer, or if it is positive infinity, the result is
the largest possible integer 0x7FFFFFFF. If the value is too small (i.e. a
negative value of large magnitude, or negative infinity) then the result is the
most negative integer 0x80000000.</desc>
<bytecode><table>
<tr>
<td>
<b> Type </b>
</td>
<td><b>Description</b></td></tr>
<tr>
<td>
u1 
</td>
<td>d2i
opcode = 0x8E (142)
</td></tr>
</table></bytecode>
<see>d2l, d2f</see>
</opcode>
<opcode>
<name>d2l</name>
<short>convert double to long integer</short>
<stack><table>
<tr>
<td>
<b>Before </b>
</td>
<td><b>After</b></td></tr>
<tr>
<td>double-word1</td>
<td>long-word1</td></tr>
<tr>
<td>double-word2</td>
<td>long-word2</td></tr>
<tr>
<td>...</td>
<td>...</td></tr>
</table></stack>
<desc>Pops a two-word double precision floating point number off of the
operand stack, converts it into a 64-bit long integer, and pushes the resulting
two-word long onto the stack. 

Rounding is done using IEEE 754 round-to-nearest mode. The fractional part is
lost by rounding towards zero, so (long)-3.14 becomes -3.

If the original double value is NaN, the result is 0. If the value is too large
to be represented as an integer, or if it is positive infinity, the result is
the largest possible long integer Long.MAX_VALUE. If the value is too small
(i.e. a negative value of large magnitude, or negative infinity) then the
result is the most negative long integer Long.MIN_VALUE. 

In some implementations, this may be coded using the C casting mechanism, e.g.

<pre>
void d2l(double d, int &amp;l_high, int &amp;l_low)
{
    l_low = (unsigned int)d;
	l_high = (unsigned int)(d / 2**32);
}
</pre>
where
l_low and l_high are respectively the least significant and most significant
32-bit words of the long.</desc>
<bytecode><table>
<tr>
<td>
<b> Type </b>
</td>
<td><b>Description</b></td></tr>
<tr>
<td>
u1 
</td>
<td>d2l
opcode = 0x8F (143)
</td></tr>
</table></bytecode>
<see>d2i, d2f</see>
</opcode>
<opcode>
<name>dadd</name>
<short>add two doubles</short>
<stack><table>
<tr>
<td>
<b>Before </b>
</td>
<td><b>After</b></td></tr>
<tr>
<td>value1-word1</td>
<td>result-word1</td></tr>
<tr>
<td>value1-word2</td>
<td>result-word2</td></tr>
<tr>
<td>value2-word1</td>
<td>...</td></tr>
<tr>
<td>value2-word2</td>
<td>...</td></tr>
<tr>
<td>...</td>
<td>...</td></tr>
</table></stack>
<desc>Takes the two top double-precision floating point numbers off of the
operand stack, adds them, and pushes the result back onto the stack.</desc>
<bytecode><table>
<tr>
<td>
<b> Type </b>
</td>
<td><b>Description</b></td></tr>
<tr>
<td>
u1 
</td>
<td>dadd
opcode = 0x63 (99)
</td></tr>
</table></bytecode>
<see>iadd, fadd, ladd</see>
<note>The addition is computed using IEEE 754 round-to-nearest mode and
gradual underflow. Standard IEEE arithmetic rules are used for the special NaN,
infinity, and zero values.</note>
</opcode>
<opcode>
<name>daload</name>
<short>retrieve double-precision float from array</short>
<stack><table>
<tr>
<td>
<b>Before </b>
</td>
<td><b>After</b></td></tr>
<tr>
<td>index</td>
<td>value-word1</td></tr>
<tr>
<td>arrayref</td>
<td>value-word2</td></tr>
<tr>
<td>...</td>
<td>...</td></tr>
</table></stack>
<desc>Retrieves an entry from a double precision float array and places it on
the stack. <i>arrayref</i> is a reference to an array of double-precision
floating point numbers. <i>index</i> is an int. The <i>arrayref</i> and
<i>index</i> are removed from the stack, and the two-word value at the given
<i>index</i> in the array is pushed onto the stack.</desc>
<example><pre>
; This is like the Java code:
;     double x = arr[0];
; where x is local variable 2 and arr is a double array in local variable 1
aload_1       ; load local variable 1 onto the stack
iconst_0      ; push the integer 0 onto the stack
daload        ; retrieve the entry
dstore_2      ; store the entry in local variable 2
</pre>
<b>
Exceptions</b>

NullPointerException - <i>arrayref</i> is null

ArrayIndexOutOfBoundsException - <i>index</i> is &lt; 0 or is &gt;=
arrayref.length</example>
<bytecode><table>
<tr>
<td>
<b> Type </b>
</td>
<td><b>Description</b></td></tr>
<tr>
<td>
u1 
</td>
<td>daload
opcode = 0x31 (49)
</td></tr>
</table></bytecode>
<see>iaload, faload, laload, aaload,
baload, caload, saload, iastore,
lastore, fastore, dastore, aastore,
bastore, castore, sastore</see>
<note>Array indices start at 0 (the first entry in the array is at
<i>index</i> 0).</note>
</opcode>
<opcode>
<name>dcmpg</name>
<short>compare two doubles (1 on NaN)</short>
<stack><table>
<tr>
<td>
<b>Before </b>
</td>
<td><b>After</b></td></tr>
<tr>
<td>value1-word1</td>
<td>int-result</td></tr>
<tr>
<td>value1-word2</td>
<td>...</td></tr>
<tr>
<td>value2-word1</td>
<td>...</td></tr>
<tr>
<td>value2-word2</td>
<td>...</td></tr>
<tr>
<td>...</td>
<td>...</td></tr>
</table></stack>
<desc>This takes two double-precision floating point numbers off the operand
stack and compares them, using IEEE 754 rules.

If the two numbers are the same, the int 0 is pushed onto the stack. If
<i>value2</i> is greater than <i>value1</i>, the int 1 is pushed onto the
stack. If  <i>value1</i> is greater than <i>value2</i>, -1 is pushed onto the
stack. If either numbers is NaN, the int 1 is pushed onto the stack. +0.0 and
-0.0 are treated as equal.</desc>
<example><pre>
dload_1       ; push the double in local variable 1
dconst_0      ; push the double 0.0 onto the stack
dcmpg         ; compare the two numbers

; The integer result on the stack is:
;     0 if local variable 1 equals 0
;     -1 if local variable 1 is less than 0
;     1 if local variable 1 is greater than 0
</pre></example>
<bytecode><table>
<tr>
<td>
<b> Type </b>
</td>
<td><b>Description</b></td></tr>
<tr>
<td>
u1 
</td>
<td>dcmpg
opcode = 0x98 (152)
</td></tr>
</table></bytecode>
<see>lcmp, fcmpl, fcmpg, dcmpl</see>
<note>This instruction is identical to dcmpl except for the treatment
of NaN.</note>
</opcode>
<opcode>
<name>dcmpl</name>
<short>compare two doubles (-1 on NaN)</short>
<stack><table>
<tr>
<td>
<b>Before </b>
</td>
<td><b>After</b></td></tr>
<tr>
<td>value1-word1</td>
<td>int-result</td></tr>
<tr>
<td>value1-word2</td>
<td>...</td></tr>
<tr>
<td>value2-word1</td>
<td>...</td></tr>
<tr>
<td>value2-word2</td>
<td>...</td></tr>
<tr>
<td>...</td>
<td>...</td></tr>
</table></stack>
<desc>This takes two double-precision floating point numbers off the operand
stack and compares them, using IEEE 754 rules. 

If the two numbers are the same, the 32-bit integer 0 is pushed onto the stack.
If <i>value2</i> is greater than <i>value1</i>, the integer 1 is pushed onto
the stack. If  <i>value1</i> is greater than <i>value2</i>, -1 is pushed onto
the stack. If either numbers is NaN, the integer 1 is pushed onto the stack.
+0.0 and -0.0 are treated as equal.</desc>
<example><pre>
dload_1       ; push the double in local variable 1
dconst_0      ; push the double 0.0 onto the stack
dcmpl         ; compare the two numbers

; The integer result on the stack is:
;     0 if local variable 1 equals 0
;     -1 if local variable 1 is less than 0
;     1 if local variable 1 is greater than 0
</pre></example>
<bytecode><table>
<tr>
<td>
<b> Type </b>
</td>
<td><b>Description</b></td></tr>
<tr>
<td>
u1 
</td>
<td>dcmpl
opcode = 0x97 (151)
</td></tr>
</table></bytecode>
<see>lcmp, fcmpl, fcmpg, dcmpg</see>
<note>This instruction is identical to dcmpg except for the treatment
of NaN.</note>
</opcode>
<opcode>
<name>ddiv</name>
<short>divides two doubles</short>
<stack><table>
<tr>
<td>
<b>Before </b>
</td>
<td><b>After</b></td></tr>
<tr>
<td>value1-word1</td>
<td>result-word1</td></tr>
<tr>
<td>value1-word2</td>
<td>result-word2</td></tr>
<tr>
<td>value2-word1</td>
<td>...</td></tr>
<tr>
<td>value2-word2</td>
<td>...</td></tr>
<tr>
<td>...</td>
<td>...</td></tr>
</table></stack>
<desc>Pops the top two double-precision floating point numbers off of the
stack, divides by the top number (i.e. computes <i>value2</i> / <i>value1</i>),
and pushes the double precision quotient result back onto the stack.

Division by zero will result in an infinity result. The division is computed
using IEEE 754 round-to-nearest mode and gradual underflow. Standard IEEE
arithmetic rules are used for the special NaN, infinity, and zero values.</desc>
<bytecode><table>
<tr>
<td>
<b> Type </b>
</td>
<td><b>Description</b></td></tr>
<tr>
<td>
u1 
</td>
<td>ddiv
opcode = 0x6F (111)
</td></tr>
</table></bytecode>
<see>idiv, ldiv, fdiv</see>
</opcode>
<opcode>
<name>dload</name>
<short>retrieve double from local variable</short>
<stack><table>
<tr>
<td>
<b>Before </b>
</td>
<td><b>After</b></td></tr>
<tr>
<td>...</td>
<td>result-word1</td></tr>
<tr>
<td></td>
<td>result-word2</td></tr>
<tr>
<td></td>
<td>...</td></tr>
</table></stack>
<desc>dload retrieves a double-precision floating point number held
in local variable and pushes it onto the operand stack.

Since double-precision floats are 64-bits wide, and each local
variable only holds up to 32 bits, Java uses two consecutive local variables,
&lt;varnum&gt; and &lt;varnum&gt; + 1  to store a double. So dload
&lt;varnum&gt; actually places the values of both &lt;varnum&gt; and
&lt;varnum&gt; + 1 onto the operand stack. 

Both &lt;varnum&gt; and &lt;varnum&gt; + 1 must be valid local variable numbers
in the current frame, and together they must be holding a double. 

Remember that attempting to treat two-word values as two independent
single-word values will produce a verification error. So trying to retrieve
&lt;varnum&gt; or &lt;varnum&gt; + 1 independently (e.g. iload
&lt;varnum&gt;) will produce a verification error. Similarly, if you store
a non-double value in &lt;varnum&gt;, then &lt;varnum&gt; + 1 becomes
invalidated until a new value is stored in it.</desc>
<example><pre>
dload 2         ; push the double held in local variables 2 and 3 onto the stack
</pre></example>
<bytecode><table>
<tr>
<td>
<b> Type </b>
</td>
<td><b>Description</b></td></tr>
<tr>
<td>
u1 
</td>
<td>dload
opcode = 0x18 (24)
</td></tr>
<tr>
<td>
u1 
</td>
<td>&lt;varnum&gt;</td></tr>
</table>
There
is also a wide format for this instruction, which supports access to
all local variables from 0 to 65535:
<table>
<tr>
<td>
<b> Type </b>
</td>
<td><b>Description</b></td></tr>
<tr>
<td>u1</td>
<td>wide
opcode = 0xC4 (196)
</td></tr>
<tr>
<td>u1</td>
<td>dload
opcode = 0x18 (24)
</td></tr>
<tr>
<td>u2</td>
<td>&lt;varnum&gt;</td></tr>
</table></bytecode>
<see>fload, iload, aload, lload,
wide</see>
</opcode>
<opcode>
<name>dstore</name>
<short>store double in local variable</short>
<stack><table>
<tr>
<td>
<b>Before </b>
</td>
<td><b>After</b></td></tr>
<tr>
<td>doube-word1</td>
<td>...</td></tr>
<tr>
<td>double-word2</td>
<td>...</td></tr>
<tr>
<td>...</td>
<td>...</td></tr>
</table></stack>
<desc>dstore pops a two-word double-precision float off the operand
stack and stores it in a local variable. It takes a single parameter,
&lt;varnum&gt;, an unsigned integer indicating which local variable to use.

Since double-precision floats are 64-bits wide, and each local
variable can only hold up to 32 bits, Java uses two consecutive local
variables, &lt;varnum&gt; and &lt;varnum&gt; + 1  to store a double. So
dstore &lt;varnum&gt; actually modifies the values of both
&lt;varnum&gt; (which is set to double<i>-word1</i>) and &lt;varnum&gt; + 1
(which is set to <i>double-word2).</i>

<i></i>Both &lt;varnum&gt; and &lt;varnum&gt; + 1 must be valid local variable
numbers in the current frame.</desc>
<example><pre>
ldc2_w 10.0      ; push the double 10.0 onto the stack
dstore 3        ; pop 10.0 off of the stack and store it in local variables 3 and 4
</pre></example>
<bytecode><table>
<tr>
<td>
<b> Type </b>
</td>
<td><b>Description</b></td></tr>
<tr>
<td>
u1 
</td>
<td>dstore
opcode = 0x39 (57)
</td></tr>
<tr>
<td>
u1 
</td>
<td>&lt;varnum&gt;</td></tr>
</table>
There
is also a wide format for this instruction, which supports access to
all local variables from 0 to 65535:
<table>
<tr>
<td>
<b> Type </b>
</td>
<td><b>Description</b></td></tr>
<tr>
<td>u1</td>
<td>wide
opcode = 0xC4 (196)
</td></tr>
<tr>
<td>
u1 
</td>
<td>dstore
opcode = 0x39 (57)
</td></tr>
<tr>
<td>
u2 
</td>
<td>&lt;varnum&gt;</td></tr>
</table></bytecode>
<see>lstore, fstore, istore, astore,
wide</see>
</opcode>
<opcode>
<name>dsub</name>
<short>subtract two doubles</short>
<stack><table>
<tr>
<td>
<b>Before </b>
</td>
<td><b>After</b></td></tr>
<tr>
<td>value1-word1</td>
<td>result-word1</td></tr>
<tr>
<td>value1-word2</td>
<td>result-word2</td></tr>
<tr>
<td>value2-word1</td>
<td>...</td></tr>
<tr>
<td>value2-word2</td>
<td>...</td></tr>
<tr>
<td>...</td>
<td>...</td></tr>
</table></stack>
<desc>Takes the top two double-precision floating point numbers from the
stack, subtracts the top one from the second (i.e. computes <i>value2</i> -
<i>value1</i>), and pushes the double-precision result back onto the stack.
Subtraction is done according to IEEE 754 rules for double precision floating
point numbers.</desc>
<bytecode><table>
<tr>
<td>
<b> Type </b>
</td>
<td><b>Description</b></td></tr>
<tr>
<td>
u1 
</td>
<td>dsub
opcode = 0x67 (103)
</td></tr>
</table></bytecode>
<see>isub, lsub, fsub</see>
</opcode>
<opcode>
<name>dup</name>
<short>duplicate top single-word item on the stack</short>
<stack><table>
<tr>
<td>
<b>Before </b>
</td>
<td><b>After</b></td></tr>
<tr>
<td>item</td>
<td>item</td></tr>
<tr>
<td>...</td>
<td>item</td></tr>
<tr>
<td></td>
<td>...</td></tr>
</table></stack>
<desc>This pops the top single-word value off the operand stack, and then
pushes that value twice - i.e. it makes an extra copy of the top item on the
stack.

This instruction cannot be used to duplicate two-word items (longs or doubles)
- use dup2 instead.</desc>
<example><pre>
; This is like the java expression:
;
;   StringBuffer x = new StringBuffer();
;

; Make a new StringBuffer object and leave a reference to it
; on the stack:
new java/lang/StringBuffer

; [ Stack now contains: objectref ]

; Duplicate the object reference:
dup

; [ Stack now contains: objectref objectref ]

; Invoke the object's initializer:
invokespecial java/lang/StringBuffer/&lt;init&gt;()V

; [ Stack now contains: objectref ]

; Store the objectref in local variable 1.
astore_1

; [ Stack is now empty. ]

</pre></example>
<bytecode><table>
<tr>
<td>
<b> Type </b>
</td>
<td><b>Description</b></td></tr>
<tr>
<td>
u1 
</td>
<td>dup
opcode = 0x59 (89)
</td></tr>
</table></bytecode>
<see>dup2, dup_x1, dup2_x1, dup2_x2</see>
</opcode>
<opcode>
<name>dup2</name>
<short>duplicate top two stack words</short>
<stack><table>
<tr>
<td>
<b>Before </b>
</td>
<td><b>After</b></td></tr>
<tr>
<td>word1</td>
<td>word1</td></tr>
<tr>
<td>word2</td>
<td>word2</td></tr>
<tr>
<td>...</td>
<td>word1</td></tr>
<tr>
<td></td>
<td>word2</td></tr>
<tr>
<td></td>
<td>...</td></tr>
</table></stack>
<desc>Duplicates the top two words on the stack and pushes the duplicates onto
the stack in the same order. You can use this to duplicate two single-word
items (e.g. two integers, or an integer and an object reference) or one
two-word item (i.e. a double or a long).</desc>
<bytecode><table>
<tr>
<td>
<b> Type </b>
</td>
<td><b>Description</b></td></tr>
<tr>
<td>
u1 
</td>
<td>dup2
opcode = 0x5C (92)
</td></tr>
</table></bytecode>
<see>dup, dup_x1, dup2_x1, dup2_x2</see>
</opcode>
<opcode>
<name>dup_x1</name>
<short>duplicate top stack word and insert beneath second
word</short>
<stack><table>
<tr>
<td>
<b>Before </b>
</td>
<td><b>After</b></td></tr>
<tr>
<td>word1</td>
<td>word1</td></tr>
<tr>
<td>word2</td>
<td>word2</td></tr>
<tr>
<td>...</td>
<td>word1</td></tr>
<tr>
<td></td>
<td>...</td></tr>
</table></stack>
<desc>Duplicates the top item on the stack and inserts the duplicate below the
second-from-top item. Both items must be single-word items.</desc>
<bytecode><table>
<tr>
<td>
<b> Type </b>
</td>
<td><b>Description</b></td></tr>
<tr>
<td>
u1 
</td>
<td>dup_x1
= 0x5A (90)
</td></tr>
</table></bytecode>
<see>dup, dup2, dup2_x1, dup2_x2</see>
<note>This instruction cannot be used if either of item1 or item2 are two-word
items. To duplicate a two-word item (a long or a double) you must use
dup2, dup2_x1 or dup2_x2.</note>
</opcode>
<opcode>
<name>dup_x2</name>
<short>duplicate top stack word and insert beneath third word</short>
<stack><table>
<tr>
<td>
<b>Before </b>
</td>
<td><b>After</b></td></tr>
<tr>
<td>word1</td>
<td>word1</td></tr>
<tr>
<td>word2</td>
<td>word2</td></tr>
<tr>
<td>word3</td>
<td>word3</td></tr>
<tr>
<td>...</td>
<td>word1</td></tr>
<tr>
<td></td>
<td>...</td></tr>
</table></stack>
<desc>Duplicates the top single-word stack item inserts the duplicate three
words down.</desc>
<example><pre>
dconst_0
bipush 100
; stack now contains:
;     0.0 | double-word1
;     0.0 | double-word2
;     100   integer

dup_x2
; stack now contains:
;     100   integer1
;     0.0 | double-word1
;     0.0 | double-word2
;     100   integer1
</pre></example>
<bytecode><table>
<tr>
<td>
<b> Type </b>
</td>
<td><b>Description</b></td></tr>
<tr>
<td>
u1 
</td>
<td>dup_x2
= 0x5B (91)
</td></tr>
</table></bytecode>
<see>dup, dup2, dup_x1, dup2_x2</see>
<note>This instruction cannot be used if the top item on the stack is a
two-word item (i.e. a long or a double-precision float). Use dup2,
dup2_x1 or dup2_x2 instead.</note>
</opcode>
<opcode>
<name>f2d</name>
<short>convert float to double</short>
<stack><table>
<tr>
<td>
<b>Before </b>
</td>
<td><b>After</b></td></tr>
<tr>
<td>float</td>
<td>double-word1</td></tr>
<tr>
<td>...</td>
<td>double-word2</td></tr>
<tr>
<td></td>
<td>...</td></tr>
</table></stack>
<desc>Pops a single precision float off of the stack, casts it to a double,
and pushes the double-precision floating point number back onto the stack. This
conversion is done in accordance with IEEE 754 specifications. Note that
nothing is lost in this conversion. If the original value is NaN, the result
will be NaN. Similarly, if the original value is an infinity, the result will
be the same infinity.</desc>
<bytecode><table>
<tr>
<td>
<b> Type </b>
</td>
<td><b>Description</b></td></tr>
<tr>
<td>
u1 
</td>
<td>f2d
opcode = 0x8D (141)
</td></tr>
</table></bytecode>
<see>f2i, f2l</see>
</opcode>
<opcode>
<name>f2i</name>
<short>convert float to integer</short>
<stack><table>
<tr>
<td>
<b>Before </b>
</td>
<td><b>After</b></td></tr>
<tr>
<td>float</td>
<td>integer</td></tr>
<tr>
<td>...</td>
<td>...</td></tr>
</table></stack>
<desc>Pops a single precision float off of the stack, casts it to a 32-bit
int, and pushes the int value back onto the stack. 

Rounding is done using IEEE 754 round-to-nearest mode. The fractional part is
lost by rounding towards zero, so (int)-3.14 becomes -3. 

If the original float value is NaN, the result is 0. If the value is too large
to be represented as an integer, or if it is positive infinity, the result is
the largest possible integer 0x7FFFFFFF. If the value is too small (i.e. a
negative value of large magnitude, or negative infinity) then the result is the
most negative integer 0x80000000.</desc>
<bytecode><table>
<tr>
<td>
<b> Type </b>
</td>
<td><b>Description</b></td></tr>
<tr>
<td>
u1 
</td>
<td>f2i
opcode = 0x8B (139)
</td></tr>
</table></bytecode>
<see>f2l, f2d</see>
</opcode>
<opcode>
<name>f2l</name>
<short>convert float to long integer</short>
<stack><table>
<tr>
<td>
<b>Before </b>
</td>
<td><b>After</b></td></tr>
<tr>
<td>float</td>
<td>long-word1</td></tr>
<tr>
<td>...</td>
<td>long-word2</td></tr>
<tr>
<td></td>
<td>...</td></tr>
</table></stack>
<desc>This is used to cast a single precision float value into a 64-bit long
integer value. f2l removes a float from the stack, converts it to a
long integer, and pushes the two-word long integer back onto the stack.

Rounding is done using IEEE 754 round-to-nearest mode. The fractional part is
lost by rounding towards zero, so (long)-3.14 becomes -3.

If the original value is NaN, the result is 0. If the value is too large to be
represented as an integer, or if it is positive infinity, the result is the
largest possible long integer Long.MAX_VALUE. If the value is too small (i.e. a
negative value of large magnitude, or negative infinity) then the result is the
most negative long integer Long.MIN_VALUE.</desc>
<bytecode><table>
<tr>
<td>
<b> Type </b>
</td>
<td><b>Description</b></td></tr>
<tr>
<td>
u1 
</td>
<td>f2l
opcode = 0x8C (140)
</td></tr>
</table></bytecode>
<see>f2i, f2d</see>
</opcode>
<opcode>
<name>fadd</name>
<short>add two floats</short>
<stack><table>
<tr>
<td>
<b>Before </b>
</td>
<td><b>After</b></td></tr>
<tr>
<td>value1</td>
<td>result</td></tr>
<tr>
<td>value2</td>
<td>...</td></tr>
<tr>
<td>...</td>
<td>...</td></tr>
</table></stack>
<desc>Pops two single-precision floating point numbers off the operand stack,
adds them, and pushes the result back onto the stack. Floating point addition
follows IEEE rules.</desc>
<bytecode><table>
<tr>
<td>
<b> Type </b>
</td>
<td><b>Description</b></td></tr>
<tr>
<td>
u1 
</td>
<td>fadd
opcode = 0x62 (98)
</td></tr>
</table></bytecode>
<see>dadd, iadd, ladd</see>
</opcode>
<opcode>
<name>faload</name>
<short>retrieve  float from array</short>
<stack><table>
<tr>
<td>
<b>Before </b>
</td>
<td><b>After</b></td></tr>
<tr>
<td>index</td>
<td>value</td></tr>
<tr>
<td>arrayref</td>
<td>...</td></tr>
<tr>
<td>...</td>
<td>...</td></tr>
</table></stack>
<desc>Retrieves an entry from a float array and places it on the stack.
<i>arrayref</i> is a reference to an array of single-precision floats.
<i>index</i> is an int. The <i>arrayref</i> and <i>index</i> are removed from
the stack, and the single-precision float entry at the given <i>index</i> in
the array is pushed onto the stack.</desc>
<example><pre>
; This is like the Java code:
;     float x = arr[0];
; where x is local variable 2 and arr is a float
; array in local variable 1
aload_1       ; load local variable 1 onto the stack
iconst_0      ; push the integer 0 onto the stack
faload        ; retrieve the entry
fstore_2      ; store the entry in local variable 2
</pre>
<b>
Exceptions</b>

NullPointerException - <i>arrayref</i> is null

ArrayIndexOutOfBoundsException - <i>index</i> is &lt; 0 or &gt;=
arrayref.length</example>
<bytecode><table>
<tr>
<td>
<b> Type </b>
</td>
<td><b>Description</b></td></tr>
<tr>
<td>
u1 
</td>
<td>faload
opcode = 0x30 (48)
</td></tr>
</table></bytecode>
<see>iaload, laload, daload, aaload,
baload, caload, saload, iastore,
lastore, fastore, dastore, aastore,
bastore, castore, sastore</see>
<note>Array indices start at 0 (the first entry in the array is at
<i>index</i> 0).</note>
</opcode>
<opcode>
<name>fcmpg</name>
<short>single-precision float comparison (1 on NaN)</short>
<stack><table>
<tr>
<td>
<b>Before </b>
</td>
<td><b>After</b></td></tr>
<tr>
<td>value1</td>
<td>int-result</td></tr>
<tr>
<td>value2</td>
<td>...</td></tr>
<tr>
<td>...</td>
<td>...</td></tr>
</table></stack>
<desc>This takes two single-precision floating point numbers off the stack and
compares them, using IEEE 754 rules.

If the two numbers are the same, the integer 0 is pushed onto the stack. If
<i>value2</i> is greater than <i>value1</i>, the integer 1 is pushed onto the
stack. If <i>value1</i> is greater than <i>value2</i>, the integer -1 is pushed
onto the stack. If either number is NaN, the integer 1 is pushed onto the
stack. +0.0 and -0.0 are treated as equal.</desc>
<example><pre>
fload_1       ; push the float in local variable 1
fconst_0      ; push the float 0 onto the stack
fcmpl         ; compare the two numbers

; The integer result on the stack is:
;     0 if local variable 1 equals 0
;     -1 if local variable 1 is less than 0
;     1 if local variable 1 is greater than 0
</pre></example>
<bytecode><table>
<tr>
<td>
<b> Type </b>
</td>
<td><b>Description</b></td></tr>
<tr>
<td>
u1 
</td>
<td>fcmpg
opcode = 0x96 (150)
</td></tr>
</table></bytecode>
<see>lcmp, fcmpl, dcmpl, dcmpg</see>
<note>This instruction is identical to fcmpl except for the treatment
of NaN.</note>
</opcode>
<opcode>
<name>fcmpl</name>
<short>single-precision float comparison (-1 on NaN)</short>
<stack><table>
<tr>
<td>
<b>Before </b>
</td>
<td><b>After</b></td></tr>
<tr>
<td>value1</td>
<td>result</td></tr>
<tr>
<td>value2</td>
<td>...</td></tr>
<tr>
<td>...</td>
<td>...</td></tr>
</table></stack>
<desc>This takes two single-precision floating point numbers off the stack and
compares them, using IEEE 754 rules.

If the two numbers are the same, the integer 0 is pushed onto the stack. If
<i>value2</i> is greater than <i>value1</i>, the integer 1 is pushed onto the
stack. If <i>value1</i> is greater than <i>value2</i>, the integer -1 is pushed
onto the stack. If either number is NaN, the integer 1 is pushed onto the
stack. +0.0 and -0.0 are treated as equal.</desc>
<example><pre>
fload_1       ; push the float in local variable 1
fconst_0      ; push the float 0 onto the stack
fcmpl         ; compare the two numbers

; The integer result on the stack is:
;     0 if local variable 1 equals 0
;     -1 if local variable 1 is less than 0
;     1 if local variable 1 is greater than 0

</pre></example>
<bytecode><table>
<tr>
<td>
<b> Type </b>
</td>
<td><b>Description</b></td></tr>
<tr>
<td>
u1 
</td>
<td>fcmpl
opcode = 0x95 (149)
</td></tr>
</table></bytecode>
<see>lcmp, fcmpg, dcmpl, dcmpg</see>
<note>This instruction is identical to fcmpg except for the treatment
of NaN.</note>
</opcode>
<opcode>
<name>fdiv</name>
<short>divide two floats</short>
<stack><table>
<tr>
<td>
<b>Before </b>
</td>
<td><b>After</b></td></tr>
<tr>
<td>value1</td>
<td>result</td></tr>
<tr>
<td>value2</td>
<td>...</td></tr>
<tr>
<td>...</td>
<td>...</td></tr>
</table></stack>
<desc>Pops two single-precision floats from the stack, divide by the top
float, and push the single-precision quotient result back onto the stack (i.e.
computes <i>value2</i> / <i>value1</i>). Division is carried out using IEEE 754
rules.</desc>
<bytecode><table>
<tr>
<td>
<b> Type </b>
</td>
<td><b>Description</b></td></tr>
<tr>
<td>
u1 
</td>
<td>fdiv
opcode = 0x6E (110)
</td></tr>
</table></bytecode>
<see>idiv, ldiv, ddiv</see>
<note>Divide by zero results in the value NaN to be pushed onto the stack</note>
</opcode>
<opcode>
<name>fload</name>
<short>retrieve  float from local variable</short>
<stack><table>
<tr>
<td>
<b>Before </b>
</td>
<td><b>After</b></td></tr>
<tr>
<td>...</td>
<td>float-value</td></tr>
<tr>
<td></td>
<td>...</td></tr>
<tr>
<td></td>
<td>...</td></tr>
</table></stack>
<desc>Pushes the float value held in a local variable onto the operand stack.
The fload instruction takes a single parameter, &lt;varnum&gt;, an
unsigned integer which indicates which local variable to retrieve. The
single-word float held in that local variable is retrieved and placed on the
stack. &lt;varnum&gt; must be a valid local variable number in the current
frame.</desc>
<example><pre>
fconst_2        ; push 2.0 onto the stack
fstore 1        ; pop 2.0 off of the stack and store in local variable 1
fload 1         ; push the value from local variable 1 (the value 2.0)
                ; back onto the stack
</pre></example>
<bytecode><table>
<tr>
<td>
<b> Type </b>
</td>
<td><b>Description</b></td></tr>
<tr>
<td>
u1 
</td>
<td>fload
opcode = 0x17 (23)
</td></tr>
<tr>
<td>
u1 
</td>
<td>&lt;varnum&gt;</td></tr>
</table>
There
is also a wide format for this instruction, which supports access to
all local variables from 0 to 65535:
<table>
<tr>
<td>
<b> Type </b>
</td>
<td><b>Description</b></td></tr>
<tr>
<td>u1</td>
<td>wide
opcode = 0xC4 (196)
</td></tr>
<tr>
<td>
u1 
</td>
<td>fload
opcode = 0x17 (23)
</td></tr>
<tr>
<td>
u2 
</td>
<td>&lt;varnum&gt;</td></tr>
</table></bytecode>
<see>iload, lload, aload, dload,
wide</see>
</opcode>
<opcode>
<name>fneg</name>
<short>negate a float</short>
<stack><table>
<tr>
<td>
<b>Before </b>
</td>
<td><b>After</b></td></tr>
<tr>
<td>value</td>
<td>value</td></tr>
<tr>
<td>...</td>
<td>...</td></tr>
</table></stack>
<desc>Removes the top single-precision float from the operand stack, negates
it (i.e. inverts its sign), and pushes the negated result back onto the
stack.

Note that, in IEEE floating point arithmetic, negation is not quite the same as
subtracting from 0. IEEE has two zeros, +0.0 and -0.0. fneg applied to +0.0 is
-0.0, whereas (+0.0 minus +0.0) is +0.0.</desc>
<bytecode><table>
<tr>
<td>
<b> Type </b>
</td>
<td><b>Description</b></td></tr>
<tr>
<td>
u1 
</td>
<td>fneg
opcode = 0x76 (118)
</td></tr>
</table></bytecode>
<see>ineg, lneg, dneg</see>
</opcode>
<opcode>
<name>frem</name>
<short>remainder of two floats</short>
<stack><table>
<tr>
<td>
<b>Before </b>
</td>
<td><b>After</b></td></tr>
<tr>
<td>value1</td>
<td>result</td></tr>
<tr>
<td>value2</td>
<td>...</td></tr>
<tr>
<td>...</td>
<td>...</td></tr>
</table></stack>
<desc>Pops two single-precision numbers off the operand stack, divides by the
top float, computes the remainder and pushes the single-precision result back
onto the stack. This is like the C function fmod. The remainder is computed
using the equation:

        remainder = <i>value2</i> - (intof( <i>value2</i> / <i>value1</i> ) *
<i>value1</i>)

where intof () rounds towards the nearest integer, or towards the nearest even
integer if the number is half way between two integers.</desc>
<bytecode><table>
<tr>
<td>
<b> Type </b>
</td>
<td><b>Description</b></td></tr>
<tr>
<td>
u1 
</td>
<td>frem
opcode = 0x72 (114)
</td></tr>
</table></bytecode>
<see>irem, lrem, drem</see>
<note>1. Divide by zero will result in NaN being pushed onto the stack as the
result.

2. This operation is not the same as the IEEE-defined remainder operation,
which uses slightly different rules for rounding. Use the Java library routine
Math.IEEEremainder if you want the IEEE behavior.</note>
</opcode>
<opcode>
<name>fstore</name>
<short>store float in local variable</short>
<stack><table>
<tr>
<td>
<b>Before </b>
</td>
<td><b>After</b></td></tr>
<tr>
<td>value</td>
<td>...</td></tr>
<tr>
<td>...</td>
<td>...</td></tr>
</table></stack>
<desc>Pops a single-precision float off the stack and stores it in local
variable &lt;varnum&gt;. The fstore instruction takes a single
parameter, &lt;varnum&gt;, an unsigned integer which indicates which local
variable is used. &lt;varnum&gt; must be a valid local variable number in the
current frame.</desc>
<example><pre>
fconst_2        ; push 2.0 onto the stack
fstore 3        ; pop 2.0 off of the stack and store it in local variable 3
</pre></example>
<bytecode><table>
<tr>
<td>
<b> Type </b>
</td>
<td><b>Description</b></td></tr>
<tr>
<td>
u1 
</td>
<td>fstore
opcode = 0x38 (56)
</td></tr>
<tr>
<td>
u1 
</td>
<td>&lt;varnum&gt;</td></tr>
</table>
There
is also a wide format for this instruction, which supports access to
all local variables from 0 to 65535:
<table>
<tr>
<td>
<b> Type </b>
</td>
<td><b>Description</b></td></tr>
<tr>
<td>u1</td>
<td>wide
opcode = 0xC4 (196)
</td></tr>
<tr>
<td>u1</td>
<td>fstore
opcode = 0x38 (56)
</td></tr>
<tr>
<td>u2</td>
<td>&lt;varnum&gt;</td></tr>
</table></bytecode>
<see>lstore, istore, dstore, astore,
wide</see>
</opcode>
<opcode>
<name>fsub</name>
<short>subtract two floats</short>
<stack><table>
<tr>
<td>
<b>Before </b>
</td>
<td><b>After</b></td></tr>
<tr>
<td>value1</td>
<td>result</td></tr>
<tr>
<td>value2</td>
<td>...</td></tr>
<tr>
<td>...</td>
<td>...</td></tr>
</table></stack>
<desc>Pops two single-precision floating point numbers off the operand stack,
subtracts the top one from the second (i.e. computes <i>value2</i> -
<i>value1</i>), and pushes the single-precision result back onto the stack.
Subtraction is done according to IEEE 754 rules for single precision floating
point numbers.</desc>
<bytecode><table>
<tr>
<td>
<b> Type </b>
</td>
<td><b>Description</b></td></tr>
<tr>
<td>
u1 
</td>
<td>fsub
opcode = 0x66 (102)
</td></tr>
</table></bytecode>
<see>isub, lsub, dsub</see>
</opcode>
<opcode>
<name>goto</name>
<short>branch to address</short>
<stack><table>
<tr>
<td>
<b>Before </b>
</td>
<td><b>After</b></td></tr>
<tr>
<td>...</td>
<td>...</td></tr>
</table></stack>
<desc>Causes execution to branch to the instruction at the address (<i>pc</i>
+ <i>branchoffset</i>), where <i>pc</i> is the address of the goto
opcode in the bytecode and <i>branchoffset</i> is a 16-bit signed integer
parameter that immediately follows the goto opcode in the bytecode. In
Jasmin, <i>branchoffset</i> is computed for you using the address associated
with &lt;label&gt;.</desc>
<example><pre>
;
; This is like the Java code:
;     while (true) { i++; }

Label:
   incr 1 1       ; Increment local variable 1 by 1
   goto Label     ; jump back to Label
</pre></example>
<bytecode><table>
<tr>
<td>
<b> Type </b>
</td>
<td><b>Description</b></td></tr>
<tr>
<td>
u1 
</td>
<td>goto
opcode = 0xA7 (167)
</td></tr>
<tr>
<td>
s2 
</td>
<td><i>branchoffset</i></td></tr>
</table></bytecode>
<see>goto_w, jsr, jsr_w</see>
<note>Addresses are measured in bytes from the start of the bytecode - i.e.
address 0 is the first byte in the bytecode of the currently executing method.
The maximum address in a method is 65535.</note>
</opcode>
<opcode>
<name>goto_w</name>
<short>branch  to address using wide offset</short>
<stack><table>
<tr>
<td>
<b>Before </b>
</td>
<td><b>After</b></td></tr>
<tr>
<td>...</td>
<td>...</td></tr>
</table></stack>
<desc>Causes execution to branch to the instruction  at the address (<i>pc</i>
+ <i>branchoffset</i>), where <i>pc</i> is the address of the goto_w
opcode in the bytecode and <i>branchoffset</i> is a 32-bit signed integer
parameter that follows the goto_w opcode in the bytecode. If you are
using Jasmin, <i>branchoffset</i> is determined for you from the address
associated with &lt;label&gt;.</desc>
<bytecode><table>
<tr>
<td>
<b> Type </b>
</td>
<td><b>Description</b></td></tr>
<tr>
<td>
u1 
</td>
<td>goto_w
opcode = 0xC8 (200)
</td></tr>
<tr>
<td>
s4 
</td>
<td>branchoffset</td></tr>
</table></bytecode>
<see>goto, jsr, jsr_w</see>
<note>1. goto_w is identical to goto, except that a 32-bit
signed integer <i>branchoffset</i> is used instead of a 16-bit
<i>branchoffset</i>. 

2. In Jasmin, goto and goto_w are synonymous, since the
Jasmin assembler automatically decides which version of the instruction to use,
based on the address of  the&lt;label&gt;.

3. Addresses are measured in bytes from the start of the bytecode - i.e.
address 0 is the first byte in the bytecode of the currently executing method.
The maximum address in a method is 65535.</note>
</opcode>
<opcode>
<name>i2b</name>
<short>convert integer to byte</short>
<stack><table>
<tr>
<td>
<b>Before </b>
</td>
<td><b>After</b></td></tr>
<tr>
<td>value</td>
<td>result</td></tr>
<tr>
<td>...</td>
<td>...</td></tr>
</table></stack>
<desc>Converts an integer to a signed byte.  A 32-bit int is popped off the
stack, the top 24 bits are discarded (they are set to zero), then the resulting
value is signed extended to an int.  The int result is pushed back onto the
stack. 

i2b is used in Java where there is a cast between an int and a byte. Notice
that i2b can cause a change in sign. For example, in the code:

<pre>
    int x = -134;
    byte b = (byte)x;
</pre>
The
value of b is positive 122 - the sign bit of x is lost in the conversion.</desc>
<bytecode><table>
<tr>
<td>
<b> Type </b>
</td>
<td><b>Description</b></td></tr>
<tr>
<td>
u1 
</td>
<td>i2b
opcode = 0x91 (145)
</td></tr>
</table></bytecode>
<see>i2c, i2s</see>
</opcode>
<opcode>
<name>i2c</name>
<short>convert integer to character</short>
<stack><table>
<tr>
<td>
<b>Before </b>
</td>
<td><b>After</b></td></tr>
<tr>
<td>value</td>
<td>result</td></tr>
<tr>
<td>...</td>
<td>...</td></tr>
</table></stack>
<desc>Converts an integer to a 16-bit unsigned char.  A 32-bit int is popped
off the stack, the top 16 bits are set to zero and the resulting int value is
pushed back onto the stack. 

i2c is used in Java when there is an explicit cast between an int and a char.
Notice that i2c produces an unsigned value - any sign bit for the original
number is lost. For example, in the code:

<pre>
    int x = -1;
    char c = (char)x;
</pre>
The
value of c is positive 0xFFFF.</desc>
<bytecode><table>
<tr>
<td>
<b> Type </b>
</td>
<td><b>Description</b></td></tr>
<tr>
<td>
u1 
</td>
<td>i2c
opcode = 0x92 (146)
</td></tr>
</table></bytecode>
<see>i2b, i2s</see>
</opcode>
<opcode>
<name>i2d</name>
<short>convert integer to double</short>
<stack><table>
<tr>
<td>
<b>Before </b>
</td>
<td><b>After</b></td></tr>
<tr>
<td>int</td>
<td>double-word1</td></tr>
<tr>
<td>...</td>
<td>double-word2</td></tr>
<tr>
<td></td>
<td>...</td></tr>
</table></stack>
<desc>Pops an int off the operand stack, casts it into a double precision
floating point number, and pushes the two-word double precision result back
onto the stack. This conversion is exact, since doubles have enough precision
to represent all int values.</desc>
<bytecode><table>
<tr>
<td>
<b> Type </b>
</td>
<td><b>Description</b></td></tr>
<tr>
<td>
u1 
</td>
<td>i2d
opcode = 0x87 (135)
</td></tr>
</table></bytecode>
<see>i2f, i2l</see>
</opcode>
<opcode>
<name>i2f</name>
<short>convert integer to float</short>
<stack><table>
<tr>
<td>
<b>Before </b>
</td>
<td><b>After</b></td></tr>
<tr>
<td>int</td>
<td>float</td></tr>
<tr>
<td>...</td>
<td>...</td></tr>
</table></stack>
<desc>Pops an int off the operand stack, casts it into a single-precision
<i>float</i>, and pushes the <i>float</i> back onto the stack. Notice that
there is may be a loss of precision (floats have 24 bits of significand, as
compared to 32 bits for an <i>int</i>, so the least significant bits of int are
lost). However, the magnitude of the result will be preserved (the range of a
float is greater than the range of an int). Rounding is done using the IEEE 754
round-to-nearest mode.</desc>
<bytecode><table>
<tr>
<td>
<b> Type </b>
</td>
<td><b>Description</b></td></tr>
<tr>
<td>
u1 
</td>
<td>i2f
opcode = 0x86 (134)
</td></tr>
</table></bytecode>
<see>i2l, i2d</see>
</opcode>
<opcode>
<name>i2l</name>
<short>convert  integer to long integer</short>
<stack><table>
<tr>
<td>
<b>Before </b>
</td>
<td><b>After</b></td></tr>
<tr>
<td>int</td>
<td>long-word1</td></tr>
<tr>
<td>...</td>
<td>long-word2</td></tr>
<tr>
<td></td>
<td>...</td></tr>
</table></stack>
<desc>Pops an integer off the operand stack, sign extends it into a long
integer, and pushes the two-word long back onto the stack.</desc>
<bytecode><table>
<tr>
<td>
<b> Type </b>
</td>
<td><b>Description</b></td></tr>
<tr>
<td>
u1 
</td>
<td>i2l
opcode = 0x85 (133)
</td></tr>
</table></bytecode>
<see>i2f, i2d</see>
</opcode>
<opcode>
<name>i2s</name>
<short>convert integer to short integer</short>
<stack><table>
<tr>
<td>
<b>Before </b>
</td>
<td><b>After</b></td></tr>
<tr>
<td>value</td>
<td>result</td></tr>
<tr>
<td>...</td>
<td>...</td></tr>
</table></stack>
<desc>Converts an integer to a signed short.  A 32-bit int is popped off the
stack, the top 16 bits are set to zero, and the resulting value is then sign
extended to an int.  The int result is pushed back onto the stack. 

i2s is used in Java where there is an explicit case between an int and a short.
Notice that i2s can cause a change in sign. For example, in the code:

<pre>
    int x = -40000;
    short s = (short)x;
</pre>
The
value of s is positive 25536, since the sign bit of x is lost in the
conversion.</desc>
<bytecode><table>
<tr>
<td>
<b> Type </b>
</td>
<td><b>Description</b></td></tr>
<tr>
<td>
u1 
</td>
<td>i2s
opcode = 0x93 (147)
</td></tr>
</table></bytecode>
<see>i2b, i2c</see>
</opcode>
<opcode>
<name>iadd</name>
<short>add two integers</short>
<stack><table>
<tr>
<td>
<b>Before </b>
</td>
<td><b>After</b></td></tr>
<tr>
<td>value1</td>
<td>result</td></tr>
<tr>
<td>value2</td>
<td>...</td></tr>
<tr>
<td>...</td>
<td>...</td></tr>
</table></stack>
<desc>Pops two integers from the operand stack, adds them, and pushes the
integer result back onto the stack. On overflow, iadd produces a result whose
low order bits are correct, but whose sign bit may be incorrect.</desc>
<example><pre>
bipush  5       ; push first int
bipush  4       ; push second int
iadd            ; add integers

                ; the top of the stack now
                ; contains the integer 9
</pre></example>
<bytecode><table>
<tr>
<td>
<b> Type </b>
</td>
<td><b>Description</b></td></tr>
<tr>
<td>
u1 
</td>
<td>iadd
opcode = 0x60 (96)
</td></tr>
</table></bytecode>
<see>ladd, fadd, dadd</see>
</opcode>
<opcode>
<name>iaload</name>
<short>retrieve integer from array</short>
<stack><table>
<tr>
<td>
<b>Before </b>
</td>
<td><b>After</b></td></tr>
<tr>
<td>index</td>
<td>value</td></tr>
<tr>
<td>arrayref</td>
<td>...</td></tr>
<tr>
<td>...</td>
<td>...</td></tr>
</table></stack>
<desc>Retrieves an entry from a int array and places it on the stack.
<i>arrayref</i> is a reference to an array of ints. <i>index</i> is an int. The
<i>arrayref</i> and <i>index</i> are removed from the stack, and the int value
at the given <i>index</i> in the array is pushed onto the stack.</desc>
<example><pre>

; get x[1], where x is an int array stored in local variable 1
aload_1          ; push an integer array onto the stack
iconst_1         ; push the integer 1 onto the stack
iaload           ; get the int at index 1 from the array

                 ; the top item on the stack is now x[1]

</pre>
<b>
Exceptions</b>

NullPointerException - <i>arrayref</i> is null

ArrayIndexOutOfBoundsException - <i>index</i> is &lt; 0 or &gt;=
arrayref.length</example>
<bytecode><table>
<tr>
<td>
<b> Type </b>
</td>
<td><b>Description</b></td></tr>
<tr>
<td>
u1 
</td>
<td>iaload
opcode = 0x2E (46)
</td></tr>
</table></bytecode>
<see>laload, faload, daload, aaload,
baload, caload, saload, iastore,
lastore, fastore, dastore, aastore,
bastore, castore, sastore</see>
<note>Array indices start at 0 (the first entry in the array is at
<i>index</i> 0).</note>
</opcode>
<opcode>
<name>iand</name>
<short>integer bitwise and</short>
<stack><table>
<tr>
<td>
<b>Before </b>
</td>
<td><b>After</b></td></tr>
<tr>
<td>value1</td>
<td>result</td></tr>
<tr>
<td>value2</td>
<td>...</td></tr>
<tr>
<td>...</td>
<td>...</td></tr>
</table></stack>
<desc>Computes the bitwise and of <i>value1</i> and <i>value2</i> (which must
be ints). The int result replaces <i>value1</i> and <i>value2</i> on the
stack.</desc>
<example><pre>
; This is like the Java code:
;       int x;
;       x &amp;= 2;
;
iload_1          ; push integer in local variable 1 onto stack
iconst_2         ; push the integer 2 onto the stack
iand             ; compute the bitwise and
istore_1         ; store the result in local variable 1
</pre></example>
<bytecode><table>
<tr>
<td>
<b> Type </b>
</td>
<td><b>Description</b></td></tr>
<tr>
<td>
u1 
</td>
<td>iand
opcode = 0x7E (126)
</td></tr>
</table></bytecode>
<see>ishl, ishr, iushr, lshl,
lshr, lushr, land, ior, lor,
ixor, lxor</see>
</opcode>
<opcode>
<name>idiv</name>
<short>divide an integer by another integer</short>
<stack><table>
<tr>
<td>
<b>Before </b>
</td>
<td><b>After</b></td></tr>
<tr>
<td>value1</td>
<td>result</td></tr>
<tr>
<td>value2</td>
<td>...</td></tr>
<tr>
<td>...</td>
<td>...</td></tr>
</table></stack>
<desc>Pops the top two integers from the operand stack and divides the
second-from top integer (<i>value2</i>) by the top integer (<i>value1</i>),
i.e. computes (<i>value2</i> div <i>value1</i>). The quotient result is
truncated to the nearest integer (with rounding going towards zero, so 1.7
becomes 1) and placed on the stack.</desc>
<exceptions>ArithmeticException - attempt to divide by 0 (i.e. <i>value1</i> is 0)</exceptions>
<bytecode><table>
<tr>
<td>
<b> Type </b>
</td>
<td><b>Description</b></td></tr>
<tr>
<td>
u1 
</td>
<td>idiv
opcode = 0x6C (108)
</td></tr>
</table></bytecode>
<see>ldiv, fdiv, ddiv</see>
<note>Because of the two's-complement representation used for negative
numbers, dividing Integer.MIN_VALUE by -1 produces Integer.MIN_VALUE, not
Integer.MAX_VALUE as you might expect.</note>
</opcode>
<opcode>
<name>ifeq</name>
<short>jump if zero</short>
<stack><table>
<tr>
<td>
<b>Before </b>
</td>
<td><b>After</b></td></tr>
<tr>
<td>value</td>
<td>...</td></tr>
<tr>
<td>...</td>
<td>...</td></tr>
</table></stack>
<desc>ifeq pops the top int off the operand stack. If the int equals
zero, execution branches to the address (<i>pc</i> + <i>branchoffset</i>),
where <i>pc</i> is the address of the ifeq opcode in the bytecode and
<i>branchoffset</i> is a 16-bit signed integer parameter following the
ifeq opcode in the bytecode. If the int on the stack does not equal
zero, execution continues at the next instruction.

If you are using Jasmin, <i>branchoffset</i> is computed for you from the
address of &lt;label&gt;.</desc>
<example><pre>
    iload_1         ; push the int value in local variable 1 onto the stack
    ifeq Label      ; if the value of local variable 1 is zero, jump to Label
    return          ; return if local variable 1 is nonzero
Label:
    ; execution continues here if local variable 1 equals zero...
</pre></example>
<bytecode><table>
<tr>
<td>
<b> Type </b>
</td>
<td><b>Description</b></td></tr>
<tr>
<td>
u1 
</td>
<td>ifeq
opcode = 0x99 (153)
</td></tr>
<tr>
<td>
s2 
</td>
<td><i>branchoffset</i></td></tr>
</table></bytecode>
<see>ifnull, iflt, ifle, ifne,
ifnonnull, ifgt, ifge</see>
<note>Addresses are measured in bytes from the start of the bytecode (i.e.
address 0 is the first byte in the bytecode of the currently executing
method).</note>
</opcode>
<opcode>
<name>ifge</name>
<short>jump if greater than or equal to zero</short>
<stack><table>
<tr>
<td>
<b>Before </b>
</td>
<td><b>After</b></td></tr>
<tr>
<td>value</td>
<td>...</td></tr>
<tr>
<td>...</td>
<td>...</td></tr>
</table></stack>
<desc>ifge pops the top int off the operand stack. If the int is
greater than or equal to zero, execution branches to the address (<i>pc</i> +
<i>branchoffset</i>), where <i>pc</i> is the address of the ifge
opcode in the bytecode and <i>branchoffset</i> is a 16-bit signed integer
parameter following the ifge opcode in the bytecode. If the int on the
stack is less than zero, execution continues at the next instruction.

If you are using Jasmin, <i>branchoffset</i> is computed for you from the
address of &lt;label&gt;.</desc>
<example><pre>
    iload_1         ; push the int value in local variable 1 onto the stack
    ifge Label      ; if the value on the stack is &gt;= 0, jump to Label
    return          ; return if local variable 1 is less than zero
Label:
    ; execution continues here if local variable 1 is greater than or equals zero...
</pre></example>
<bytecode><table>
<tr>
<td>
<b> Type </b>
</td>
<td><b>Description</b></td></tr>
<tr>
<td>
u1 
</td>
<td>ifge
opcode = 0x9C (156)
</td></tr>
<tr>
<td>
s2 
</td>
<td><i>branchoffset</i></td></tr>
</table></bytecode>
<see>ifnull, ifeq, iflt, ifne,
ifnonnull, ifgt, ifle</see>
<note>Addresses are measured in bytes from the start of the bytecode (i.e.
address 0 is the first byte in the bytecode of the currently executing
method).</note>
</opcode>
<opcode>
<name>ineg</name>
<short>negate an integer</short>
<stack><table>
<tr>
<td>
<b>Before </b>
</td>
<td><b>After</b></td></tr>
<tr>
<td>value</td>
<td>-value</td></tr>
<tr>
<td></td> <td>...</td></tr>
</table></stack>
<desc>Pops an int off the stack, negates it, and pushes the negated integer
value back onto the stack. This is the same as multiplying the integer by -1.</desc>
<bytecode><table>
<tr>
<td>
<b> Type </b>
</td>
<td><b>Description</b></td></tr>
<tr>
<td>
u1 
</td>
<td>ineg
opcode = 0x74 (116)
</td></tr>
</table></bytecode>
<see>lneg, fneg, dneg</see>
<note>Because of the two's-complement representation used for negative
numbers, negating Integer.MIN_VALUE actually produces Integer.MIN_VALUE, not
Integer.MAX_VALUE as you might expect.</note>
</opcode>
<opcode>
<name>ior</name>
<short>integer bitwise or</short>
<stack><table>
<tr>
<td>
<b>Before </b>
</td>
<td><b>After</b></td></tr>
<tr>
<td>value1</td>
<td>result</td></tr>
<tr>
<td>value2</td>
<td>...</td></tr>
<tr>
<td>...</td>
<td>...</td></tr>
</table></stack>
<desc>Computes the bitwise or of <i>value1</i> and <i>value2</i> (which must
be ints). The int result replaces <i>value1</i> and <i>value2</i> on the
stack.</desc>
<example><pre>
; This is like the Java code:
;       int x;
;       x |= 2;
;
iload_1          ; load local variable 1 onto stack
iconst_2         ; push the integer 2 onto the stack
ior              ; compute the bitwise or
istore_1         ; store the result in local variable 1

</pre></example>
<bytecode><table>
<tr>
<td>
<b> Type </b>
</td>
<td><b>Description</b></td></tr>
<tr>
<td>
u1 
</td>
<td>ior
opcode = 0x80 (128)
</td></tr>
</table></bytecode>
<see>ishl, ishr, iushr, lshl,
lshr, lushr, iand, land, lor,
ixor, lxor</see>
</opcode>
<opcode>
<name>irem</name>
<short>remainder of two integers</short>
<stack><table>
<tr>
<td>
<b>Before </b>
</td>
<td><b>After</b></td></tr>
<tr>
<td>value1</td>
<td>result</td></tr>
<tr>
<td>value2</td>
<td>...</td></tr>
<tr>
<td>...</td>
<td>...</td></tr>
</table></stack>
<desc>Pops two ints off the operand stack, divides <i>value2</i> by
<i>value1</i> (i.e. value2 / value1), computes the remainder and pushes the int
remainder back onto the stack. The remainder is (value2 - ((value1 / value2) *
value2)). This is used by the % operator in Java.</desc>
<exceptions>ArithmeticException - the divisor (<i>value1</i>) is zero.</exceptions>
<bytecode><table>
<tr>
<td>
<b> Type </b>
</td>
<td><b>Description</b></td></tr>
<tr>
<td>
u1 
</td>
<td>irem
opcode = 0x70 (112)
</td></tr>
</table></bytecode>
<see>lrem, frem, drem</see>
</opcode>
<opcode>
<name>ishl</name>
<short>integer shift left</short>
<stack><table>
<tr>
<td>
<b>Before </b>
</td>
<td><b>After</b></td></tr>
<tr>
<td>value1</td>
<td>result</td></tr>
<tr>
<td>value2</td>
<td>...</td></tr>
<tr>
<td>...</td>
<td>...</td></tr>
</table></stack>
<desc>Pops two ints off the stack. Shifts <i>value2</i> left by the amount
indicated in the five low bits of <i>value1</i>. The int result is then pushed
back onto the stack.

This is the same as computing the expression:

     x * 2<sup>s</sup>

<sup>where s is value1 and x is value2. </sup></desc>
<example><pre>
; This is like the Java code:
;      int x;
;      x &lt;&lt;= 3;
;
iload_1          ; push integer in local variable 1 onto stack
iconst_3         ; push the integer 3 onto the stack
ishl             ; shift left
istore_1         ; store the result in local variable 1

</pre></example>
<bytecode><table>
<tr>
<td>
<b> Type </b>
</td>
<td><b>Description</b></td></tr>
<tr>
<td>
u1 
</td>
<td>ishl
opcode = 0x78 (120)
</td></tr>
</table></bytecode>
<see>ishr, iushr, lshl, lshr,
lushr, iand, land, ior, lor,
ixor, lxor</see>
</opcode>
<opcode>
<name>ishr</name>
<short>integer arithmetic shift right</short>
<stack><table>
<tr>
<td>
<b>Before </b>
</td>
<td><b>After</b></td></tr>
<tr>
<td>value1</td>
<td>result</td></tr>
<tr>
<td>value2</td>
<td>...</td></tr>
<tr>
<td>...</td>
<td>...</td></tr>
</table></stack>
<desc>Pops two ints off the stack. Shifts <i>value1</i> right by the amount
indicated in the five low bits of <i>value2</i>. The int result is then pushed
back onto the stack. <i>value1</i> is shifted arithmetically (preserving the
sign extension).

This is the same as computing the expression:

     x / 2<sup>s</sup>

<sup>where s is value1 and x is value2. </sup></desc>
<example><pre>
; This is like the Java code:
;      int x;
;      x &gt;&gt;= 3;
;
iload_1          ; load local variable 1 onto stack
iconst_3         ; push the integer 3 onto the stack
ishr             ; arithmetic shift right
istore_1         ; store the result in local variable 1

</pre></example>
<bytecode><table>
<tr>
<td>
<b> Type </b>
</td>
<td><b>Description</b></td></tr>
<tr>
<td>
u1 
</td>
<td>ishr
opcode = 0x7A (122)
</td></tr>
</table></bytecode>
<see>ishl, iushr, lshl, lshr,
lushr, iand, land, ior, lor,
ixor, lxor</see>
</opcode>
<opcode>
<name>istore</name>
<short>store integer in local variable</short>
<stack><table>
<tr>
<td>
<b>Before </b>
</td>
<td><b>After</b></td></tr>
<tr>
<td>value</td>
<td>...</td></tr>
<tr>
<td>...</td>
<td>...</td></tr>
</table></stack>
<desc>Pops an in off the stack and stores it in local variable &lt;varnum&gt;.
The istore instruction takes a single parameter, &lt;varnum&gt;, an
unsigned integer which indicates which local variable should be used.
&lt;varnum&gt; must be a valid local variable number in the current frame.</desc>
<example><pre>
bipush 10       ; push 10 onto the stack
istore 3        ; pop 10 off of the stack and store it in local variable 3
</pre></example>
<bytecode><table>
<tr>
<td>
<b> Type </b>
</td>
<td><b>Description</b></td></tr>
<tr>
<td>
u1 
</td>
<td>istore
opcode = 0x36 (54)
</td></tr>
<tr>
<td>
u1 
</td>
<td>&lt;varnum&gt;</td></tr>
</table>
There
is also a wide format for this instruction, which supports access to
all local variables from 0 to 65535:
<table>
<tr>
<td>
<b> Type </b>
</td>
<td><b>Description</b></td></tr>
<tr>
<td>u1</td>
<td>wide
opcode = 0xC4 (196)
</td></tr>
<tr>
<td>
u1 
</td>
<td>istore
opcode = 0x36 (54)
</td></tr>
<tr>
<td>
u2 
</td>
<td>&lt;varnum&gt;</td></tr>
</table></bytecode>
<see>lstore, fstore, dstore, astore,
wide</see>
</opcode>
<opcode>
<name>isub</name>
<short>subtract two integers</short>
<stack><table>
<tr>
<td>
<b>Before </b>
</td>
<td><b>After</b></td></tr>
<tr>
<td>value1</td>
<td>result</td></tr>
<tr>
<td>value2</td>
<td>...</td></tr>
<tr>
<td>...</td>
<td>...</td></tr>
</table></stack>
<desc>Pops two ints off the operand stack, subtracts the top one from the
second (i.e. computes <i>value2</i> - <i>value1</i>), and pushes the int result
back onto the stack.</desc>
<bytecode><table>
<tr>
<td>
<b> Type </b>
</td>
<td><b>Description</b></td></tr>
<tr>
<td>
u1 
</td>
<td>isub
opcode = 0x64 (100)
</td></tr>
</table></bytecode>
<see>lsub, fsub, dsub</see>
</opcode>
<opcode>
<name>iushr</name>
<short>integer logical shift right</short>
<stack><table>
<tr>
<td>
<b>Before </b>
</td>
<td><b>After</b></td></tr>
<tr>
<td>value1</td>
<td>result</td></tr>
<tr>
<td>value2</td>
<td>...</td></tr>
<tr>
<td>...</td>
<td>...</td></tr>
</table></stack>
<desc>Pops two ints off the operand stack. Shifts <i>value1</i> right by the
amount indicated in the five low bits of <i>value2</i>. The int result is then
pushed back onto the stack. 

<i>value1</i> is shifted logically (ignoring the sign extension - useful for
unsigned values).</desc>
<example><pre>
; This is like the Java code:
;      int x;
;      x &gt;&gt;&gt;= 3;
;
iload_1          ; load local variable 1 onto stack
iconst_3         ; push the integer 3 onto the stack
iushr            ; logical shift right
istore_1         ; store the result in local variable 1
</pre></example>
<bytecode><table>
<tr>
<td>
<b> Type </b>
</td>
<td><b>Description</b></td></tr>
<tr>
<td>
u1 
</td>
<td>iushr
opcode = 0x7C (124)
</td></tr>
</table></bytecode>
<see>ishl, ishr, lshl, lshr,
lushr, iand, land, ior, lor,
ixor, lxor</see>
</opcode>
<opcode>
<name>ixor</name>
<short>integer bitwise exclusive or</short>
<stack><table>
<tr>
<td>
<b>Before </b>
</td>
<td><b>After</b></td></tr>
<tr>
<td>value1</td>
<td>result</td></tr>
<tr>
<td>value2</td>
<td>...</td></tr>
<tr>
<td>...</td>
<td>...</td></tr>
</table></stack>
<desc>Pops two integers off the operand stack. Computes the bitwise exclusive
or of <i>value1</i> and <i>value2</i>. The integer result replaces
<i>value1</i> and <i>value2</i> on the stack.</desc>
<example><pre>
; This is like the Java code:
;       int x;
;       x ^= 2;
;
iload_1          ; load local variable 1 onto stack
iconst_2         ; push the integer 2 onto the stack
ixor             ; compute the bitwise exclusive or
istore_1         ; store the result in local variable 1
</pre></example>
<bytecode><table>
<tr>
<td>
<b> Type </b>
</td>
<td><b>Description</b></td></tr>
<tr>
<td>
u1 
</td>
<td>ixor
opcode = 0x82 (130)
</td></tr>
</table></bytecode>
<see>ishl, ishr, iushr, lshl,
lshr, lushr, iand, land, ior,
lor, lxor</see>
</opcode>
<opcode>
<name>jsr</name>
<short>jump to subroutine</short>
<stack><table>
<tr>
<td>
<b>Before </b>
</td>
<td><b>After</b></td></tr>
<tr>
<td>...</td>
<td>return-address</td></tr>
<tr>
<td></td>
<td>...</td></tr>
</table></stack>
<desc>This calls a local subroutine defined within the body of a method. It is
used to implement Java's finally clause.

jsr first pushes the address (<i>pc</i> + 3) onto the operand stack,
where <i>pc</i> is the address of this jsr instruction in the
bytecode. The address (<i>pc</i> + 3) is  the address of instruction that
immediately follows the jsr instruction in bytecode - it is used  used
by the ret instruction to return from the subroutine. 

Next, execution branches to the address (<i>pc</i> + <i>branchoffset</i>),
where <i>pc</i> is the address of the jsr opcode in the bytecode and
<i>branchoffset</i> is the 16-bit signed integer parameter following the
jsr opcode in the bytecode. If you are using Jasmin,
<i>branchoffset</i> is computed for you from the address of &lt;label&gt;.</desc>
<example><pre>
; This example method uses a PrintMe subroutine to invoke the System.out.println() method.

.method usingSubroutine()V
    ldc "Message 1"
    jsr PrintMe          ; print "Message 1"

    ldc "Message 2"
    jsr PrintMe          ; print "Message 2"

    ldc "Message 3"
    jsr PrintMe          ; print "Message 3"

    return   ; now return from usingSubroutine

; define the PrintMe subroutine ...
PrintMe:       
    astore_1            ; store return-address in local variable 1
    ; call System.out.println()
    getstatic java/lang/System/out Ljava/io/PrintStream;
    invokevirtual java/io/PrintStream/println(Ljava/lang/String;)V

    ret 1               ; return to the return-address in local variable 1
.end method
</pre></example>
<bytecode><table>
<tr>
<td>
<b> Type </b>
</td>
<td><b>Description</b></td></tr>
<tr>
<td>
u1 
</td>
<td>jsr
opcode = 0xA8 (168)
</td></tr>
<tr>
<td>
s2 
</td>
<td><i>branchoffset</i></td></tr>
</table></bytecode>
<see>jsr_w, ret, goto, goto_w</see>
<note>1. Addresses are measured in bytes from the start of the bytecode (i.e.
address 0 is the first byte in the bytecode of the currently executing
method).

2. Subroutines complicate the work of the class file verifier, so extensive use
of subroutines may slow down verification speeds.</note>
</opcode>
<opcode>
<name>jsr_w</name>
<short>jump to subroutine using wide offset</short>
<stack><table>
<tr>
<td>
<b>Before </b>
</td>
<td><b>After</b></td></tr>
<tr>
<td>...</td>
<td>return-address</td></tr>
<tr>
<td></td>
<td>...</td></tr>
</table></stack>
<desc>This calls a local subroutine defined within the body of a method. It is
used to implement Java's finally clause.

jsr_w first pushes the address (<i>pc</i> + 5) onto the operand stack,
where <i>pc</i> is the address of this jsr_w instruction in the
bytecode. The address (<i>pc</i> + 5) is  the address of instruction that
immediately follows the jsr_w instruction in bytecode - it is used
used by the ret instruction to return from the subroutine. 

Next, execution branches to the address (<i>pc</i> + <i>branchoffset</i>),
where <i>pc</i> is the address of the jsr_w opcode in the bytecode and
<i>branchoffset</i> is the 32-bit signed integer parameter following the
jsr_w opcode in the bytecode.  If you are using Jasmin,
<i>branchoffset</i> is computed for you from the address of &lt;label&gt;.</desc>
<bytecode><table>
<tr>
<td>
<b> Type </b>
</td>
<td><b>Description</b></td></tr>
<tr>
<td>
u1 
</td>
<td>jsr_w
opcode = 0xC9 (201)
</td></tr>
<tr>
<td>
s4 
</td>
<td><i>branchoffset</i></td></tr>
</table></bytecode>
<see>jsr, ret, goto, goto_w</see>
<note>1. jsr_w is identical to the jsr instruction except
that it uses a 32-bit wide offset instead of a 16-bit wide
offset.

2. Addresses are measured in bytes from the start of the bytecode (i.e. address
0 is the first byte in the bytecode of the currently executing method). The
maximum address in a method is 65535.

3. In Jasmin, jsr and jsr_w are synonymous, since the Jasmin
assembler automatically decides which version of the instruction to use, based
on the address of  the&lt;label&gt;.</note>
</opcode>
<opcode>
<name>l2d</name>
<short>convert long to double</short>
<stack><table>
<tr>
<td>
<b>Before </b>
</td>
<td><b>After</b></td></tr>
<tr>
<td>long-word1</td>
<td>double-word1</td></tr>
<tr>
<td>long-word2</td>
<td>double-word2</td></tr>
<tr>
<td>...</td>
<td>...</td></tr>
</table></stack>
<desc>Pops a long integer off of the stack, casts it into a double precision
floating point number, and pushes the double back onto the stack. Notice that
this can cause loss of precision (the significand in a double is 54 bits,
compared to 64 bits for the long) though not loss of magnitude (since the range
of a double is greater than the range of a long). Rounding is done using the
IEEE 754 round-to-nearest mode.</desc>
<bytecode><table>
<tr>
<td>
<b> Type </b>
</td>
<td><b>Description</b></td></tr>
<tr>
<td>
u1 
</td>
<td>l2d
opcode = 0x8A (138)
</td></tr>
</table></bytecode>
<see>l2i, l2f</see>
</opcode>
<opcode>
<name>l2f</name>
<short>convert long to float</short>
<stack><table>
<tr>
<td>
<b>Before </b>
</td>
<td><b>After</b></td></tr>
<tr>
<td>long-word1</td>
<td>float</td></tr>
<tr>
<td>long-word2</td>
<td>...</td></tr>
<tr>
<td>...</td>
<td>...</td></tr>
</table></stack>
<desc>Pops a long integer off of the stack, casts it into a single precision
floating point number, and pushes the single <i>float</i> back onto the stack.
Notice that this can cause loss of precision (the significand in a float is 24
bits, compared to 64 bits for the long) though not loss of magnitude (since the
range of a float is greater than the range of a long). Rounding is done using
the IEEE 754 round-to-nearest mode.</desc>
<bytecode><table>
<tr>
<td>
<b> Type </b>
</td>
<td><b>Description</b></td></tr>
<tr>
<td>
u1 
</td>
<td>l2f
opcode = 0x89 (137)
</td></tr>
</table></bytecode>
<see>l2i, l2d</see>
</opcode>
<opcode>
<name>l2i</name>
<short>long to integer conversion</short>
<stack><table>
<tr>
<td>
<b>Before </b>
</td>
<td><b>After</b></td></tr>
<tr>
<td>long-word1</td>
<td>integer</td></tr>
<tr>
<td>long-word2</td>
<td>...</td></tr>
<tr>
<td>...</td>
<td>...</td></tr>
</table></stack>
<desc>Pops a long integer off of the stack, discards the most significant 32
bits, and pushes the low 32 bits onto the stack as an int. This may cause the
magnitude or sign of the value to change.</desc>
<bytecode><table>
<tr>
<td>
<b> Type </b>
</td>
<td><b>Description</b></td></tr>
<tr>
<td>
u1 
</td>
<td>l2i
opcode = 0x88 (136)
</td></tr>
</table></bytecode>
<see>l2f, l2d</see>
</opcode>
<opcode>
<name>ladd</name>
<short>add two long integers</short>
<stack><table>
<tr>
<td>
<b>Before </b>
</td>
<td><b>After</b></td></tr>
<tr>
<td>value1-word1</td>
<td>result-word1</td></tr>
<tr>
<td>value1-word2</td>
<td>result-word2</td></tr>
<tr>
<td>value2-word1</td>
<td>...</td></tr>
<tr>
<td>value2-word2</td>
<td>...</td></tr>
<tr>
<td>...</td>
<td>...</td></tr>
</table></stack>
<desc>Pops two long integers from the operand stack, adds them and then pushes
the result back onto the stack. On overflow, ladd produces a result whose low
order bits are correct, but whose sign bit may be incorrect.</desc>
<bytecode><table>
<tr>
<td>
<b> Type </b>
</td>
<td><b>Description</b></td></tr>
<tr>
<td>
u1 
</td>
<td>ladd
0x61 (97)
</td></tr>
</table></bytecode>
<see>iadd, fadd, dadd</see>
</opcode>
<opcode>
<name>laload</name>
<short>retrieve long integer from array</short>
<stack><table>
<tr>
<td>
<b>Before </b>
</td>
<td><b>After</b></td></tr>
<tr>
<td>index</td>
<td>value-word1</td></tr>
<tr>
<td>arrayrefref</td>
<td>value-word2</td></tr>
<tr>
<td>...</td>
<td>...</td></tr>
</table></stack>
<desc>Retrieves a long integer from a long integer array and places it on the
stack. <i>arrayref</i> is a reference to an array of long integers.
<i>index</i> is an int. The <i>arrayref</i> and <i>index</i> are removed from
the stack, and the long integer entry at the given <i>index</i> in the array is
pushed onto the stack.</desc>
<example><pre>
; This is like the Java code:
;     long x = arr[0];
; where x is local variable 2 and arr is an array of longs in local variable 1
aload_1       ; load local variable 1 onto the stack
iconst_0      ; push the integer 0 onto the stack
laload        ; retrieve the entry
lstore_2      ; store the entry in local variables 2 and 3
</pre>
<b>
Exceptions</b>

NullPointerException - <i>arrayref</i> is null

ArrayIndexOutOfBoundsException - <i>index</i> is &lt; 0 or &gt;=
arrayref.length</example>
<bytecode><table>
<tr>
<td>
<b> Type </b>
</td>
<td><b>Description</b></td></tr>
<tr>
<td>
u1 
</td>
<td>laload
opcode = 0x2F (47)
</td></tr>
</table></bytecode>
<see>iaload, faload, daload, aaload,
baload, caload, saload, iastore,
lastore, fastore, dastore, aastore,
bastore, castore, sastore</see>
<note>Array indices start at 0 (the first entry in the array is at
<i>index</i> 0).</note>
</opcode>
<opcode>
<name>land</name>
<short>long integer bitwise and</short>
<stack><table>
<tr>
<td>
<b>Before </b>
</td>
<td><b>After</b></td></tr>
<tr>
<td>value1-word1</td>
<td>result-word1</td></tr>
<tr>
<td>value1-word2</td>
<td>result-word2</td></tr>
<tr>
<td>value2-word1</td>
<td>...</td></tr>
<tr>
<td>value2-word2</td>
<td>...</td></tr>
<tr>
<td>...</td>
<td>...</td></tr>
</table></stack>
<desc>Pops two long integers off the stack. Computes the bitwise and of
<i>value1</i> and <i>value2</i>. The long integer result replaces <i>value1</i>
and <i>value2</i> on the stack.</desc>
<example><pre>
; This is like the Java code:
;       long x;
;       x &amp;= 1;
;
lload_1          ; push the long integer in local variable 1
lconst_1         ; push the integer 1 onto the stack
land             ; compute the bitwise and
lstore_1         ; store the long result in local variable 1

</pre></example>
<bytecode><table>
<tr>
<td>
<b> Type </b>
</td>
<td><b>Description</b></td></tr>
<tr>
<td>
u1 
</td>
<td>land
opcode = 0x7F (127)
</td></tr>
</table></bytecode>
<see>ishl, ishr, iushr, lshl,
lshr, lushr, iand, ior, lor,
ixor, lxor</see>
</opcode>
<opcode>
<name>lcmp</name>
<short>long integer comparison</short>
<stack><table>
<tr>
<td>
<b>Before </b>
</td>
<td><b>After</b></td></tr>
<tr>
<td>value1-word1</td>
<td>int-result</td></tr>
<tr>
<td>value1-word2</td>
<td>...</td></tr>
<tr>
<td>value2-word1</td>
<td>...</td></tr>
<tr>
<td>value2-word2</td>
<td>...</td></tr>
<tr>
<td>...</td>
<td>...</td></tr>
</table></stack>
<desc>Takes two two-word long integers off the stack and compares them. If the
two integers are the same, the int 0 is pushed onto the stack. If <i>value2</i>
is greater than <i>value1</i>, the int 1 is pushed onto the stack. If
<i>value1</i> is greater than <i>value2</i>, the int -1 is pushed onto the
stack.</desc>
<example><pre>
; This is like the Java expression:
;     (x &gt; 0)
; where x is a long.

lload_1       ; push the long int in local variable 1
lconst_0      ; push the long integer 0 onto the stack
lcmp          ; compare the two long integers

; The integer result on the stack is:
;     0 if local variable 1 equals 0
;     -1 if local variable 1 is less than 0
;     1 if local variable 1 is greater than 0
</pre></example>
<bytecode><table>
<tr>
<td>
<b> Type </b>
</td>
<td><b>Description</b></td></tr>
<tr>
<td>
u1 
</td>
<td>lcmp
opcode = 0x94 (148)
</td></tr>
</table></bytecode>
<see>fcmpl, fcmpg, dcmpl, dcmpg</see>
</opcode>
<opcode>
<name>ldc</name>
<short>push single-word constant onto stack</short>
<stack><table>
<tr>
<td>
<b>Before </b>
</td>
<td><b>After</b></td></tr>
<tr>
<td>...</td>
<td>&lt;value&gt;</td></tr>
<tr>
<td></td>
<td>...</td></tr>
</table></stack>
<desc>ldc pushes a one-word constant onto the operand stack.
ldc takes a single parameter, <i>&lt;</i>value<i>&gt;</i>, which is
the value to push. The following Java types can be pushed using ldc:

	int
	float
	String

Pushing a String causes a reference to a java.lang.String object to be
constructed and pushed onto the operand stack. Pusing an int or a float causes
a primitive value to be pushed onto the stack.</desc>
<example><pre>
ldc "Hello World"     ; push string "Hello World" onto stack
ldc 10                ; push the integer 10
ldc 1.54              ; push the single-precision float 1.54
</pre></example>
<exceptions>OutOfMemoryError - not enough memory to allocate a reference to a
String</exceptions>
<bytecode><table>
<tr>
<td>
<b> Type </b>
</td>
<td><b>Description</b></td></tr>
<tr>
<td>
u1 
</td>
<td>ldc
opcode = 0x12 (18)
</td></tr>
<tr>
<td>
u1 
</td>
<td>index</td></tr>
</table></bytecode>
<see>bipush, sipush, ldc_w, ldc2_w,
aconst_null, iconst_m1, iconst_&lt;n&gt;,
lconst_&lt;l&gt;, fconst_&lt;f&gt;,
dconst_&lt;d&gt;</see>
<note>1. Where possible, its more efficient to use one of bipush,
sipush, or one of the const instructions instead of ldc.

2. If the same string constant (i.e. a string with the same sequence of
characters) appears in several different class files, only one String instance
is built for that constant. The String.intern() method can be used to retrieve
the instance used for a given sequence of characters.</note>
</opcode>
<opcode>
<name>ldc_w</name>
<short>push single-word constant onto stack (wide index)</short>
<stack><table>
<tr>
<td>
<b>Before </b>
</td>
<td><b>After</b></td></tr>
<tr>
<td>...</td>
<td>&lt;value&gt;</td></tr>
<tr>
<td></td>
<td>...</td></tr>
</table></stack>
<desc>ldc_w pushes a one-word constant onto the operand stack.
ldc_w takes a single parameter, <i>&lt;</i>value<i>&gt;</i>, which is
the value to push. The following Java types can be pushed using
ldc_w:

	int
	float
	String

Pushing a String causes a reference to a java.lang.String object to be
constructed and pushed onto the stack. Pusing an int or a float causes a
primitive value to be pushed onto the stack.

ldc_w is identical to ldc except that, in bytecode,
ldc_w uses a 16-bit index rather than an 8-bit index.</desc>
<exceptions>OutOfMemoryError - not enough memory to allocate a reference to a
String</exceptions>
<bytecode><table>
<tr>
<td>
<b> Type </b>
</td>
<td><b>Description</b></td></tr>
<tr>
<td>
u1 
</td>
<td>ldc_w
opcode = 0x13 (19)
</td></tr>
<tr>
<td>
u2 
</td>
<td>index</td></tr>
</table></bytecode>
<see>bipush, sipush, ldc, ldc2_w,
aconst_null, iconst_m1, iconst_&lt;n&gt;,
lconst_&lt;l&gt;, fconst_&lt;f&gt;,
dconst_&lt;d&gt;</see>
<note>1. Where possible, its more efficient to use one of bipush,
sipush, or one of the const instructions instead of ldc_w.

2. If the same string constant (i.e. a string with the same sequence of
characters) appears in several different class files, only one String instance
is built for that constant. The String.intern() method can be used to retrieve
the instance used for a given sequence of characters.

3. The Jasmin assembler automatically determines whether to use ldc or
ldc_w, so in Jasmin assembly files these two instructions are
synonymous.</note>
</opcode>
<opcode>
<name>ldiv</name>
<short>divide a long integer</short>
<stack><table>
<tr>
<td>
<b>Before </b>
</td>
<td><b>After</b></td></tr>
<tr>
<td>value1-word1</td>
<td>result-word1</td></tr>
<tr>
<td>value1-word2</td>
<td>result-word2</td></tr>
<tr>
<td>value2-word1</td>
<td>...</td></tr>
<tr>
<td>value2-word2</td>
<td>...</td></tr>
<tr>
<td>...</td>
<td>...</td></tr>
</table></stack>
<desc>Pops the top two two-word long integers from the stack and divides by
the top long integer (i.e. computes <i>value2</i> / <i>value1</i>). The result
is rounded to the nearest integer, with rounding going towards 0. The long
integer quotient result is pushed back onto the stack.</desc>
<exceptions>ArithmeticException - the divisor (<i>value2</i>) is zero.</exceptions>
<bytecode><table>
<tr>
<td>
<b> Type </b>
</td>
<td><b>Description</b></td></tr>
<tr>
<td>
u1 
</td>
<td>ldiv
opcode = 0x6D (109)
</td></tr>
</table></bytecode>
<see>idiv, fdiv, ddiv</see>
<note>Because of the two's-complement representation used for negative
numbers, dividing Long.MIN_VALUE by -1 produces Long.MIN_VALUE, not
Long.MAX_VALUE as you might expect.</note>
</opcode>
<opcode>
<name>lmul</name>
<short>multiply two longs</short>
<stack><table>
<tr>
<td>
<b>Before </b>
</td>
<td><b>After</b></td></tr>
<tr>
<td>value1-word1</td>
<td>result-word1</td></tr>
<tr>
<td>value1-word2</td>
<td>result-word2</td></tr>
<tr>
<td>value2-word1</td>
<td>...</td></tr>
<tr>
<td>value2-word2</td>
<td>...</td></tr>
<tr>
<td>...</td>
<td>...</td></tr>
</table></stack>
<desc>Pops the top two long integers from the operand stack, multiplies them,
and then pushes the long integer result back onto the stack. On overflow, lmul
produces a result whose low order bits are correct, but whose sign bit may be
incorrect.</desc>
<bytecode><table>
<tr>
<td>
<b> Type </b>
</td>
<td><b>Description</b></td></tr>
<tr>
<td>
u1 
</td>
<td>lmul
opcode = 0x69 (105)
</td></tr>
</table></bytecode>
<see>imul, fmul, dmul</see>
</opcode>
<opcode>
<name>lneg</name>
<short>negate a long</short>
<stack><table>
<tr>
<td>
<b>Before </b>
</td>
<td><b>After</b></td></tr>
<tr>
<td>value-word1</td>
<td>result-word1</td></tr>
<tr>
<td>value-word2</td>
<td>result-word2</td></tr>
<tr>
<td>...</td>
<td>...</td></tr>
</table></stack>
<desc>Removes the top long integer from the operand stack, negates it, and
pushes the negated result back onto the stack. This is the same as multiplying
the long integer by -1, which is the same as (~value) + 1.</desc>
<bytecode><table>
<tr>
<td>
<b> Type </b>
</td>
<td><b>Description</b></td></tr>
<tr>
<td>
u1 
</td>
<td>lneg
opcode = 0x75 (117)
</td></tr>
</table></bytecode>
<see>ineg, fneg, dneg</see>
<note>Because of the two's-complement representation used for negative
numbers, negating Long.MIN_VALUE actually produces Long.MIN_VALUE, not
Long.MAX_VALUE as you might expect.</note>
</opcode>
<opcode>
<name>lor</name>
<short>long integer bitwise or</short>
<stack><table>
<tr>
<td>
<b>Before </b>
</td>
<td><b>After</b></td></tr>
<tr>
<td>value1-word1</td>
<td>result-word1</td></tr>
<tr>
<td>value1-word2</td>
<td>result-word2</td></tr>
<tr>
<td>value2-word1</td>
<td>...</td></tr>
<tr>
<td>value2-word2</td>
<td>...</td></tr>
<tr>
<td>...</td>
<td>...</td></tr>
</table></stack>
<desc>Pops two long integers off the stack. Computes the bitwise or of
<i>value1</i> and <i>value2</i>. The long integer result replaces <i>value1</i>
and <i>value2</i> on the stack.</desc>
<example><pre>
; This is like the Java code:
;       long x;
;       x |= 1;
;
lload_1          ; load long integer in local variable 1 onto stack
lconst_1         ; push the integer 1 onto the stack
lor              ; compute the bitwise or
lstore_1         ; store the long result in local variable 1
</pre></example>
<bytecode><table>
<tr>
<td>
<b> Type </b>
</td>
<td><b>Description</b></td></tr>
<tr>
<td>
u1 
</td>
<td>lor
opcode = 0x81 (129)
</td></tr>
</table></bytecode>
<see>ishl, ishr, iushr, lshl,
lshr, lushr, iand, land, ior,
ixor, lxor</see>
</opcode>
<opcode>
<name>lrem</name>
<short>modulus of two longs</short>
<stack><table>
<tr>
<td>
<b>Before </b>
</td>
<td><b>After</b></td></tr>
<tr>
<td>value1-word1</td>
<td>result-word1</td></tr>
<tr>
<td>value1-word2</td>
<td>result-word2</td></tr>
<tr>
<td>value2-word1</td>
<td>...</td></tr>
<tr>
<td>value2-word2</td>
<td>...</td></tr>
<tr>
<td>...</td>
<td>...</td></tr>
</table></stack>
<desc>Pops two long integers off the operand stack, divides <i>value2</i> by
<i>value1</i>, computes the remainder and pushes the long integer remainder
back onto the stack. The remainder is (value2 - ((value1 / value2) * value2)).
This is used by the % operator in Java.</desc>
<exceptions>ArithmeticException - the divisor (<i>value1</i>) is zero</exceptions>
<bytecode><table>
<tr>
<td>
<b> Type </b>
</td>
<td><b>Description</b></td></tr>
<tr>
<td>
u1 
</td>
<td>lrem
opcode = 0x71 (113)
</td></tr>
</table></bytecode>
<see>irem, frem, drem</see>
</opcode>
<opcode>
<name>lshl</name>
<short>long integer shift left</short>
<stack><table>
<tr>
<td>
<b>Before </b>
</td>
<td><b>After</b></td></tr>
<tr>
<td>value1</td>
<td>result-word1</td></tr>
<tr>
<td>value2-word1</td>
<td>result-word2</td></tr>
<tr>
<td>value2-word2</td>
<td>...</td></tr>
<tr>
<td>...</td>
<td>...</td></tr>
</table></stack>
<desc>Pops a long integer and an int from the stack. Shifts <i>value2</i> (the
long integer) left by the amount indicated in the low six bits of <i>value1</i>
(an int). The long integer result is then pushed back onto the stack. 

This is the same as computing the expression:

     x * 2<sup>s</sup>

<sup>where s is value1 and x is value2. </sup></desc>
<example><pre>
; This is like the Java code:
;      long x;
;      x &lt;&lt;= 3;
;
lload_1          ; load long integer in local variable 1 onto stack
iconst_3         ; push the integer 3 onto the stack
lshl             ; shift left
lstore_1         ; store the long result in local variable 1
</pre></example>
<bytecode><table>
<tr>
<td>
<b> Type </b>
</td>
<td><b>Description</b></td></tr>
<tr>
<td>
u1 
</td>
<td>lshl
opcode = 0x79 (121)
</td></tr>
</table></bytecode>
<see>ishl, ishr, iushr, lshr,
lushr, iand, land, ior, lor,
ixor, lxor</see>
</opcode>
<opcode>
<name>lshr</name>
<short>long integer arithmetic shift right</short>
<stack><table>
<tr>
<td>
<b>Before </b>
</td>
<td><b>After</b></td></tr>
<tr>
<td>value1</td>
<td>result-word1</td></tr>
<tr>
<td>value2-word1</td>
<td>result-word2</td></tr>
<tr>
<td>value2-word2</td>
<td>...</td></tr>
<tr>
<td>...</td>
<td>...</td></tr>
</table></stack>
<desc>Pops an int and a long integer from the stack. Shifts <i>value2</i> (the
long integer) right by the amount indicated in the low six bits of
<i>value1</i> (an int). The long integer<i> </i>result is then pushed back onto
the stack. The value is shifted arithmetically (preserving the sign
extension).

This is the same as computing the expression:

     x / 2<sup>s</sup>

<sup>where s is value1 and x is value2. </sup></desc>
<example><pre>
; This is like the Java code:
;      long x;
;      x &gt;&gt;= 3;
;
lload_1          ; load long in local variable 1 onto stack
iconst_3         ; push the integer 3 onto the stack
lshr             ; arithmetic shift right
lstore_1         ; store the long result in local variable 1
</pre></example>
<bytecode><table>
<tr>
<td>
<b> Type </b>
</td>
<td><b>Description</b></td></tr>
<tr>
<td>
u1 
</td>
<td>lshr
opcode = 0x7B (123)
</td></tr>
</table></bytecode>
<see>ishl, ishr, iushr, lshl,
lushr, iand, land, ior, lor,
ixor, lxor</see>
</opcode>
<opcode>
<name>lstore</name>
<short>store long integer in local variable</short>
<stack><table>
<tr>
<td>
<b>Before </b>
</td>
<td><b>After</b></td></tr>
<tr>
<td>long-word1</td>
<td>...</td></tr>
<tr>
<td>long-word2</td>
<td>...</td></tr>
<tr>
<td>...</td>
<td>...</td></tr>
</table></stack>
<desc>lstore pops a two-word long integer off the operand stack and
stores it in a local variable. It takes a single parameter, &lt;varnum&gt;, an
unsigned integer indicating which local variable to use.

Since long integers are 64-bits wide, and each local variable can only
hold up to 32 bits Java uses two consecutive local variables, &lt;varnum&gt;
and &lt;varnum&gt; + 1  to store a long. So lstore &lt;varnum&gt;
actually modifies the values of both &lt;varnum&gt; (which is set to
<i>long-word1</i>) and &lt;varnum&gt; + 1 (which is set to
<i>long-word2).</i>

<i></i>Both &lt;varnum&gt; and &lt;varnum&gt; + 1 must be valid local variable
numbers in the current frame, and together they must be holding a long. 

Remember that attempting to treat two-word values as two independent
single-word values will produce a verification error. So trying to retrieve
&lt;varnum&gt; or &lt;varnum&gt; + 1 independently (e.g. iload
&lt;varnum&gt;) will produce a verification error. Similarly, if you store
a value other than a long in &lt;varnum&gt;, then &lt;varnum&gt; + 1 becomes
invalidated until a new value is stored in it.</desc>
<example><pre>
ldc2_w 10       ; push the long integer 10 onto the stack
lstore 3        ; pop 10 off of the stack and store it in local variables 3 and 4
</pre></example>
<bytecode><table>
<tr>
<td>
<b> Type </b>
</td>
<td><b>Description</b></td></tr>
<tr>
<td>
u1 
</td>
<td>lstore
opcode = 0x37 (55)
</td></tr>
<tr>
<td>
u1
</td>
<td>&lt;varnum&gt;</td></tr>
</table>
There
is also a wide format for this instruction, which supports access to
all local variables from 0 to 65535:
<table>
<tr>
<td>
<b> Type </b>
</td>
<td><b>Description</b></td></tr>
<tr>
<td>u1</td>
<td>wide
opcode = 0xC4 (196)
</td></tr>
<tr>
<td>
u1 
</td>
<td>lstore
opcode = 0x37 (55)
</td></tr>
<tr>
<td>
u2 
</td>
<td>&lt;varnum&gt;</td></tr>
</table></bytecode>
<see>istore, fstore, dstore, astore,
wide</see>
</opcode>
<opcode>
<name>lsub</name>
<short>subtract two longs</short>
<stack><table>
<tr>
<td>
<b>Before </b>
</td>
<td><b>After</b></td></tr>
<tr>
<td>value1-word1</td>
<td>result-word1</td></tr>
<tr>
<td>value1-word2</td>
<td>result-word2</td></tr>
<tr>
<td>value2-word1</td>
<td>...</td></tr>
<tr>
<td>value2-word2</td>
<td>...</td></tr>
<tr>
<td>...</td>
<td>...</td></tr>
</table></stack>
<desc>Pops two long integers from the stack, subtracts the top one from the
second (i.e. computes <i>value2</i> - <i>value1</i>), and pushes the result
back onto the stack.</desc>
<bytecode><table>
<tr>
<td>
<b> Type </b>
</td>
<td><b>Description</b></td></tr>
<tr>
<td>
u1 
</td>
<td>lsub
opcode = 0x65 (101)
</td></tr>
</table></bytecode>
<see>isub, fsub, dsub</see>
</opcode>
<opcode>
<name>lushr</name>
<short>long integer logical shift right</short>
<stack><table>
<tr>
<td>
<b>Before </b>
</td>
<td><b>After</b></td></tr>
<tr>
<td>value1</td>
<td>result-word1</td></tr>
<tr>
<td>value2-word1</td>
<td>result-word2</td></tr>
<tr>
<td>value2-word2</td>
<td>...</td></tr>
<tr>
<td>...</td>
<td>...</td></tr>
</table></stack>
<desc>Pops an integer and a  long integer and from the stack. Shifts
<i>value2</i> (the long integer) right by the amount indicated in the low six
bits of <i>value1</i> (an int). The long integer result<i> </i>is then pushed
back onto the stack. The value is shifted logically (ignoring the sign
extension - useful for unsigned values).</desc>
<example><pre>
; This is like the Java code:
;      long x;
;      x &gt;&gt;&gt;= 3;
;
lload_1          ; load long in local variable 1 onto stack
iconst_3         ; push the integer 3 onto the stack
lushr            ; logical shift right
lstore_1         ; store the long result in local variable 1
</pre></example>
<bytecode><table>
<tr>
<td>
<b> Type </b>
</td>
<td><b>Description</b></td></tr>
<tr>
<td>
u1 
</td>
<td>lushr
opcode = 0x7D (125)
</td></tr>
</table></bytecode>
<see>ishl, ishr, iushr, lshl,
lshr, iand, land, ior, lor,
ixor, lxor</see>
</opcode>
<opcode>
<name>lxor</name>
<short>long integer bitwise exclusive or</short>
<stack><table>
<tr>
<td>
<b>Before </b>
</td>
<td><b>After</b></td></tr>
<tr>
<td>value1-word1</td>
<td>result-word1</td></tr>
<tr>
<td>value1-word2</td>
<td>result-word2</td></tr>
<tr>
<td>value2-word1</td>
<td>...</td></tr>
<tr>
<td>value2-word2</td>
<td>...</td></tr>
<tr>
<td>...</td>
<td>...</td></tr>
</table></stack>
<desc>Pops two long integers off the stack. Computes the bitwise exclusive or
of <i>value1</i> and <i>value2</i>. The long integer result replaces
<i>value1</i> and <i>value2</i> on the stack.</desc>
<example><pre>
; This is like the Java code:
;       long x;
;       x ^= 1;
;
lload_1          ; load long in local variable 1 onto stack
lconst_1         ; push the integer 1 onto the stack
lxor             ; compute the bitwise exclusive or
lstore_1         ; store the long result in local variable 1
</pre>
<b>
</b></example>
<bytecode><table>
<tr>
<td>
<b> Type </b>
</td>
<td><b>Description</b></td></tr>
<tr>
<td>
u1 
</td>
<td>lxor
opcode = 0x83 (131)
</td></tr>
</table></bytecode>
<see>ishl, ishr, iushr, lshl,
lshr, lushr, iand, land, ior,
lor, ixor</see>
</opcode>
<opcode>
<name>pop</name>
<short>discard  top word on stack</short>
<stack><table>
<tr>
<td>
<b>Before </b>
</td>
<td><b>After</b></td></tr>
<tr>
<td>item</td>
<td>...</td></tr>
<tr>
<td>...</td>
<td>...</td></tr>
</table></stack>
<desc>Pops the top single-word item off the stack and discards it.</desc>
<example><pre>
invokevirtual Myclass/test()Z  ; call boolean Myclass.test();
pop                            ; discard the boolean result
</pre></example>
<bytecode><table>
<tr>
<td>
<b> Type </b>
</td>
<td><b>Description</b></td></tr>
<tr>
<td>
u1 
</td>
<td>pop
opcode = 0x57 (87)
</td></tr>
</table></bytecode>
<see>pop2</see>
<note>1. Use pop2 to remove long integers and doubles from the stack
(using pop when the top item on the stack is a long integer or double
will cause a verification error).

2. Note there is no matching "push" instruction. Use bipush,
sipush, one of the</note>
</opcode>
<opcode>
<name>dload_&lt;n&gt;</name>
<short>retrieve double from local variables &lt;n&gt; and &lt;n&gt;
+ 1</short>
<stack><table>
<tr>
<td>
<b>Before </b>
</td>
<td><b>After</b></td></tr>
<tr>
<td>...</td>
<td>result-word1</td></tr>
<tr>
<td></td>
<td>result-word2</td></tr>
<tr>
<td></td>
<td>...</td></tr>
</table></stack>
<desc>Retrieves the double-precision float stored in local variables &lt;n&gt;
and &lt;n&gt; + 1 and pushes it onto the operand stack. Both &lt;n&gt; and
&lt;n&gt; + 1 must be valid local variable numbers in the current frame, and
together they must be holding a double. 

See the description of dload for more information on how doubles are
retrieved from local variables.   

'dload_&lt;n&gt;' is functionally equivalent to 'dload
&lt;n&gt;', although it is typically more efficient and also takes fewer bytes
in the bytecode.</desc>
<example><pre>
dload_0         ; push double in local variables 0 and 1 onto stack
dload_1         ; push double in local variables 1 and 2 onto stack
dload_2         ; push double in local variables 2 and 3 onto stack
dload_3         ; push double in local variables 3 and 4 onto stack
</pre></example>
<bytecode><table>
<tr>
<td>
<b> Type </b>
</td>
<td><b>Description</b></td></tr>
<tr>
<td>
u1 
</td>
<td>dload_0
opcode = 0x26 (38)
</td></tr>
<tr>
<td>
u1 
</td>
<td>dload_1
opcode = 0x27 (39)
</td></tr>
<tr>
<td>
u1 
</td>
<td>dload_2
opcode = 0x28 (40)
</td></tr>
<tr>
<td>
u1 
</td>
<td>dload_3
opcode = 0x29 (41)
</td></tr>
</table></bytecode>
<see>dload, fload, aload, iload,
lload</see>
</opcode>
<opcode>
<name>dstore_&lt;n&gt;</name>
<short>store double in local variables &lt;n&gt; and &lt;n&gt; +
1</short>
<stack><table>
<tr>
<td>
<b>Before </b>
</td>
<td><b>After</b></td></tr>
<tr>
<td>value-word1</td>
<td>...</td></tr>
<tr>
<td>value-word2</td>
<td>...</td></tr>
<tr>
<td>...</td>
<td>...</td></tr>
</table></stack>
<desc>Pops a double-precision float off of the operand stack and stores it in
the local variables &lt;n&gt; and &lt;n&gt; + 1. Both &lt;n&gt; and &lt;n&gt; +
1 must be valid local variable numbers in the current frame.

See the description of dstore for more information on how doubles are
stored in local variables.   

'dstore_&lt;n&gt;' is functionally equivalent to 'dstore
&lt;n&gt;', although it is typically more efficient and also takes fewer bytes
in the bytecode.</desc>
<example><pre>
dstore_0        ;store double in local variable 0 and 1
dstore_1        ;store double in local variable 1 and 2
dstore_2        ;store double in local variable 2 and 3
dstore_3        ;store double in local variable 3 and 4
</pre></example>
<bytecode><table>
<tr>
<td>
<b> Type </b>
</td>
<td><b>Description</b></td></tr>
<tr>
<td>
u1 
</td>
<td>dstore_0
opcode = 0x47 (71)
</td></tr>
<tr>
<td>
u1 
</td>
<td>dstore_1
opcode = 0x48 (72)
</td></tr>
<tr>
<td>
u1 
</td>
<td>dstore_2
opcode = 0x49 (73)
</td></tr>
<tr>
<td>
u1 
</td>
<td>dstore_3
opcode = 0x4A (74)
</td></tr>
</table></bytecode>
<see>astore, dstore, istore, fstore,
lstore</see>
</opcode>
<opcode>
<name>dup2_x1</name>
<short>duplicate two words and insert beneath third word</short>
<stack><table>
<tr>
<td>
<b>Before </b>
</td>
<td><b>After</b></td></tr>
<tr>
<td>word1</td>
<td>word1</td></tr>
<tr>
<td>word2</td>
<td>word2</td></tr>
<tr>
<td>word3</td>
<td>word3</td></tr>
<tr>
<td>...</td>
<td>word1</td></tr>
<tr>
<td></td>
<td>word2</td></tr>
<tr>
<td></td>
<td>...</td></tr>
</table></stack>
<desc>Duplicates the top two-word item on the stack and inserts the duplicate
before the previous (single-word) item on the stack. Alternatively, this
instruction could also be used to duplicate two single-word items and insert
them before the third single-word item on the stack.</desc>
<example><pre>
bipush 100
dconst_0

; stack now contains:
;     0.0 | double-word1
;     0.0 | double-word2
;     100   integer-word1

dup2_x1

; stack now contains:
;     0.0 | double-word1
;     0.0 | double-word2
;     100   integer-word1
;     0.0 | double-word1
;     0.0 | double-word2




</pre></example>
<bytecode><table>
<tr>
<td>
<b> Type </b>
</td>
<td><b>Description</b></td></tr>
<tr>
<td>
u1 
</td>
<td>dup2_x1
= 0x5D (93)
</td></tr>
</table></bytecode>
<see>dup, dup2, dup_x1, dup2_x2</see>
</opcode>
</opcodes>
